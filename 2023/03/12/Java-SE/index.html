<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java SE | Joker's Warm Cabin</title><meta name="author" content="yao chen"><meta name="copyright" content="yao chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM：java虚拟机，真正运行Java程序的地方  核心类库：Java自己写好的程序，给程序员自己的程序调用的  JRE：JAVA的运行环境，由JVM和核心类库组成  JDK：Java开发工具包，包含上面所有  IDE：集成开发环境，把代码编写，编译，执行等多种功能综合到一起的开发工具   IDEA项目结构 project：项目，工程 module：模块 package：包 class：类">
<meta property="og:type" content="article">
<meta property="og:title" content="Java SE">
<meta property="og:url" content="http://example.com/2023/03/12/Java-SE/index.html">
<meta property="og:site_name" content="Joker&#39;s Warm Cabin">
<meta property="og:description" content="JVM：java虚拟机，真正运行Java程序的地方  核心类库：Java自己写好的程序，给程序员自己的程序调用的  JRE：JAVA的运行环境，由JVM和核心类库组成  JDK：Java开发工具包，包含上面所有  IDE：集成开发环境，把代码编写，编译，执行等多种功能综合到一起的开发工具   IDEA项目结构 project：项目，工程 module：模块 package：包 class：类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/head_picture.png">
<meta property="article:published_time" content="2023-03-12T14:47:30.000Z">
<meta property="article:modified_time" content="2023-04-09T03:47:48.795Z">
<meta property="article:author" content="yao chen">
<meta property="article:tag" content="back-end">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/head_picture.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/12/Java-SE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java SE',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-09 11:47:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_picture.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Joker's Warm Cabin</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java SE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-12T14:47:30.000Z" title="发表于 2023-03-12 22:47:30">2023-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-09T03:47:48.795Z" title="更新于 2023-04-09 11:47:48">2023-04-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li><p>JVM：java虚拟机，真正运行Java程序的地方</p>
</li>
<li><p>核心类库：Java自己写好的程序，给程序员自己的程序调用的</p>
</li>
<li><p>JRE：JAVA的运行环境，由JVM和核心类库组成</p>
</li>
<li><p>JDK：Java开发工具包，包含上面所有</p>
</li>
<li><p>IDE：集成开发环境，把代码编写，编译，执行等多种功能综合到一起的开发工具</p>
</li>
</ul>
<h1 id="IDEA项目结构"><a href="#IDEA项目结构" class="headerlink" title="IDEA项目结构"></a>IDEA项目结构</h1><ul>
<li>project：项目，工程</li>
<li>module：模块</li>
<li>package：包</li>
<li>class：类</li>
</ul>
<h1 id="进制表示形式"><a href="#进制表示形式" class="headerlink" title="进制表示形式"></a>进制表示形式</h1><ul>
<li>0表示八进制</li>
<li>0B表示二进制</li>
<li>0x表示十六进制</li>
</ul>
<h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><ul>
<li>也可以成为实体类，其对象可用于在程序中封装数据</li>
</ul>
<p><strong>标准JavaBean需求：</strong></p>
<ul>
<li>成员变量使用private修饰</li>
<li>提供成员变量对应的set和get方法</li>
<li>必须提供一个无参构造器，有参构造器可写可不写</li>
</ul>
<h1 id="String常用API"><a href="#String常用API" class="headerlink" title="String常用API"></a>String常用API</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int length()</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>public char charAt(int index)</td>
<td>获取某个索引位置处的字符</td>
</tr>
<tr>
<td>public char[] toCharArray</td>
<td>将当前字符串转换为字符数组返回</td>
</tr>
<tr>
<td>public String substring(int beginIndex, int endIndex)</td>
<td>根据索引进行截取，包前不包后</td>
</tr>
<tr>
<td>public String substring(int beginIndex)</td>
<td>截取到末尾</td>
</tr>
<tr>
<td>public String replace(CharSequence target, CharSequence replacement)</td>
<td>使用新值将旧值替换，得到新的字符串</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td>根据传入规则切割字符串，得到字符串数组返回</td>
</tr>
</tbody></table>
<h1 id="ArrayList集合常用方法"><a href="#ArrayList集合常用方法" class="headerlink" title="ArrayList集合常用方法"></a>ArrayList集合常用方法</h1><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public E get(int index)</td>
<td>返回指定索引的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中元素的个数</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>public boolean remove(Object o)</td>
<td>删除指定的元素，返回删除是否成功</td>
</tr>
<tr>
<td>public E set(int index, E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
</tbody></table>
<h1 id="static静态关键字"><a href="#static静态关键字" class="headerlink" title="static静态关键字"></a>static静态关键字</h1><ul>
<li><p>static是静态的意思，可以修饰成员变量和成员方法</p>
<p><strong>修饰成员变量</strong></p>
</li>
<li><p>static修饰成员变量表示该成员在内存中只存储一份，可以被共享访问，修改</p>
</li>
<li><p>静态成员变量有static修饰，属于类，加载一次，可以被共享访问（类名.静态成员变量）</p>
</li>
<li><p>实例成员变量无static修饰，属于对象</p>
<p><strong>修饰成员方法</strong></p>
</li>
<li><p>静态成员方法有static修饰，归属于类，建议用类名访问</p>
</li>
<li><p>实例成员方法无static修饰，归属于对象，只能用对象触发访问</p>
</li>
<li><p>表示对象自己行为的，方法中需要访问实例成员的，该方法申明为实例方法</p>
</li>
<li><p>该方法是以执行一个共用功能为目的，申明为静态方法</p>
<p><strong>注意事项</strong></p>
</li>
<li><p>静态方法只能访问静态的成员，不可以直接访问实例成员</p>
</li>
<li><p>实例方法可以访问静态成员，也可以访问实例成员</p>
</li>
<li><p>静态方法不能出现this关键字</p>
<p><strong>工具类</strong></p>
</li>
<li><p>类中都是静态方法，每个方法以完成一个公用的功能为目的，提高代码重用性</p>
</li>
<li><p>由于工具类中均是静态方法，直接用类名访问，工具类无需创建对象，将工具类的构造器私有</p>
<p><strong>代码块</strong></p>
</li>
<li><p>代码块是类的五大成分（成员变量、构造器、方法、代码块、内部类），定义在类的方法之外</p>
</li>
<li><p>在Java类下，使用{}括起来的代码被称为代码块</p>
</li>
<li><p><strong>静态代码块：</strong></p>
<ul>
<li><code>static&#123;&#125;</code></li>
<li>需要通过static关键字修饰，随着类的加载而加载，自动触发，执行一次</li>
<li>在类加载时做一些静态数据初始化的操作，以便后续使用</li>
</ul>
</li>
<li><p><strong>构造代码块</strong></p>
<ul>
<li><code>&#123;&#125;</code></li>
<li>每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行</li>
<li>初始化实例资源</li>
</ul>
</li>
<li><p><strong>单例模式</strong></p>
<ul>
<li><p>饿汉单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">singleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">singleInstance</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleInstance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>super调用父类有参构造器作用：初始化继承自父类的数据（如果父类中没有无参构造器，只有有参构造器则会报错，子类默认调用父类的无参构造器）</li>
<li>子类构造器中可以通过书写super(…)，手动调用父类的有参数构造器</li>
<li><strong><code>this(...)</code>和<code>super(...)</code>注意点：</strong><ul>
<li>子类通过<code>this(...)</code>去调用本类的其他构造器，本类的其他构造器会通过<code>super()</code>去手动调用父类的构造器，最终还是调用父类的构造器</li>
<li><code>this(...)</code>和<code>super(...)</code>只能放在构造器的第一行，所以二者不能放在同一个构造器中</li>
</ul>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li><p>包</p>
<ul>
<li><p>包是用来分门别类管理各种不同类的，类似于文件夹，建包利于程序的管理和维护</p>
</li>
<li><p>导包：相同包下的类可以直接访问，不同包下的类必须导包才可以使用。<strong>导包格式：<code>import 包名.类名</code></strong></p>
</li>
<li><p>如果这个类中使用不同包下相同的类名，此时默认只能导入一个类的包，另一个类要使用全名访问</p>
</li>
</ul>
</li>
<li><p>权限修饰符</p>
<ul>
<li><p>用来控制一个成员能够被访问的范围</p>
</li>
<li><p>可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制</p>
</li>
<li><table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同一个包中的其他类</th>
<th>不同包下的子类</th>
<th>不同包下的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>final</code></p>
<ul>
<li>修饰类：表明该类是最终类，不能被继承</li>
<li>修饰方法：表明该方法是最终方法，不能被重写</li>
<li>修饰变量：表示该变量第一次赋值后，不能被再次赋值</li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li>常量是使用了<code>public static final</code>修饰的成员变量，必须有初始化值，而且在执行的过程中值不能被改变</li>
<li>常量的作用和好处：用作系统的配置信息，方便程序维护，提高可读性</li>
</ul>
</li>
<li><p>枚举</p>
<ul>
<li>枚举是Java中的一种特殊数据类型</li>
<li>枚举的作用：为了做信息的标志和信息的分类</li>
<li>枚举格式</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修饰符 enum 枚举名称&#123;</span></span><br><span class="line"><span class="comment"> * 第一行是罗列枚举的实例名称</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul>
<li>类有的成员（成员变量、方法、构造器）抽象类都具备</li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>
<li>一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义为抽象类</li>
<li>不能用abstract修饰变量、代码块、构造器</li>
<li><strong>得到了抽象方法，失去了创建对象的能力</strong></li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li>接口不能创建对象</li>
<li>一个类实现多个接口，多个接口中有同样的静态方法不冲突</li>
<li>一个类继承了父类，同时又实现了接口，父类中和接口有同名方法，默认使用父类的</li>
<li>一个类实现了多个接口，多个接口存在同名的默认的方法，不冲突，该类重写该方法即可</li>
<li>一个接口继承了多个接口，是允许的，但多个接口中存在规范冲突则不能继承</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li><p>方法调用：编译看左边，运行看右边</p>
</li>
<li><p>变量调用：编译看左边，运行也看左边</p>
</li>
<li><p>多态前提：有继承&#x2F;实现关系，有父类引用指向子类对象，有方法重写</p>
</li>
<li><p>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</p>
</li>
<li><p>定义方法时，使用父类型作为参数，该方法就可以接受这父类的一切子类对象，体现出多态的扩展性和便利</p>
</li>
<li><p><strong>多态下不能使用子类的独有功能</strong></p>
</li>
<li><p><strong>自动类型转换：</strong>子类对象赋值给父类类型的变量指向</p>
</li>
<li><p>强制类型转换</p>
<ul>
<li>此时必须进行强制类型转换，如果转型后的类型和对象的真实类型不是一种类型，在转换时出现<code>ClassCastException</code></li>
</ul>
</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul>
<li><p>内部类就是定义在一个类里的类</p>
</li>
<li><p>静态内部类</p>
<ul>
<li>static修饰，属于外部类本身</li>
<li>特点与使用与普通类完全一样，只是位置位于其他类里而已</li>
<li>创建格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类构造器</code></li>
<li><strong>静态内部类不可以直接访问外部类的实例成员，必须通过外部类对象访问</strong></li>
</ul>
</li>
<li><p>成员内部类</p>
<ul>
<li>无static修饰，属于外部类的对象</li>
<li>JDK16之前，成员内部类不能定义静态成员，16开始可以定义静态成员</li>
<li>成员内部类创建对象格式：<code>外部类名.内部类名 对象名 = new 外部类构造器.new 内部类构造器()</code></li>
<li><strong>成员内部类可以直接访问外部类的静态成员，也可以直接访问外部类的实例成员</strong></li>
</ul>
</li>
<li><p><strong>匿名内部类</strong></p>
<ul>
<li>本质上是一个没有名字的局部内部类，定义在方法、代码块等中</li>
<li>作用：方便创建子类对象，最终目的都是为了简化代码</li>
<li>格式：<code>new 类|抽象类名|接口名()&#123;重写方法&#125;;</code></li>
<li>匿名内部类是一个没有名字的内部类</li>
<li>匿名内部类写出来就会产生一个匿名内部类的对象</li>
<li>匿名内部类的对象类型相当于是new的那个的类型的子类类型</li>
</ul>
</li>
</ul>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><ul>
<li><strong><code>Object类</code></strong><ul>
<li>一个类要么默认继承<code>Object</code>类，要么间接继承<code>Object</code>类，<code>Object</code>是JAVA的祖宗类</li>
<li>Object类的方法是一切子类都可以使用的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public String toString()</code></td>
<td>默认返回当前对象在堆内存中的地址信息</td>
</tr>
<tr>
<td>public Boolean equals(Object o)</td>
<td>比较当前对象与另一个对象的地址是否相同</td>
</tr>
</tbody></table>
<p>默认是打印当前对象的地址</p>
<p>让子类重写，以便返回子类对象的内容</p>
<ul>
<li><p><strong><code>Object</code>中的equals方法</strong></p>
<ul>
<li>默认是与另一个对象比较地址是否一样</li>
<li>让子类重写，以便比较2个子类对象的内容是否相同</li>
</ul>
</li>
<li><p><strong>Objects概述</strong></p>
<ul>
<li><p>Objects类与Object还是继承关系，Objects类是从jdk1.7开始的</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static boolean equals(Object a , Object b)</td>
<td>比较两个对象，底层会先进行非空判断，从而可以避免指针异常，在进行equals比较</td>
</tr>
<tr>
<td>public static boolean isNull(Object obj)</td>
<td>判断变量是否为null，为null返回true</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>StringBuilder</code></p>
<ul>
<li><code>StringBuilder</code>是一个可变的字符串类，可以将其看成一个对象容器</li>
<li>作用：提高字符串的操作效率，如拼接，修改</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder()</td>
<td>创建一个空白的可变的字符串对象，不包含任何内容</td>
</tr>
<tr>
<td>public StringBuilder(String str)</td>
<td>创建一个指定字符串内容的可变字符串对象</td>
</tr>
</tbody></table>
<ul>
<li><p><code>Math类</code></p>
<ul>
<li><p><code>Math类</code>没有公开的构造器</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static int abs (int a)</code></td>
<td>取绝对值</td>
</tr>
<tr>
<td><code>public static double ceil(double a)</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>public static double floor(double a)</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>public static int round(float a)</code></td>
<td>四舍五入</td>
</tr>
<tr>
<td><code>public static int max(int a, int b)</code></td>
<td>取最大值</td>
</tr>
<tr>
<td><code>public static double pow(double a, double b)</code></td>
<td>a的b次方</td>
</tr>
<tr>
<td><code>public static double random()</code></td>
<td>返回double的随机值，[0.0, 1.0)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>System</code>类</p>
<ul>
<li><p>System的功能是通用的，直接用类名调用，System不能被实例化</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static void exit(int status)</code></td>
<td>终止当前运行的JAVA虚拟机，非零表示异常终止</td>
</tr>
<tr>
<td><code>public static long currentTimeMills()</code></td>
<td>返回当前系统时间毫秒值形式</td>
</tr>
<tr>
<td><code>public static void arraycopy(数据源数组，起始索引，目的地数组，启示拷贝，拷贝个数)</code></td>
<td>数组拷贝</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>BigDecimal</strong></p>
<ul>
<li><p>解决浮点型运算精度问题</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public BigDecimal add(BigDecimal b)</code></td>
<td>加法</td>
</tr>
<tr>
<td><code>public BigDecimal subtract(BigDecimal b)</code></td>
<td>减法</td>
</tr>
<tr>
<td><code>public BigDecimal multiply(BigDecimal b)</code></td>
<td>乘法</td>
</tr>
<tr>
<td><code>public BigDecimal divide(BigDecimal b)</code></td>
<td>除法</td>
</tr>
<tr>
<td><code>public BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式)</code></td>
<td>除法</td>
</tr>
</tbody></table>
</li>
<li><p><strong>获取对象方式：<code>BigDecimal b1 = BigDecimal.valueOf(0.1)</code></strong></p>
</li>
<li><p>如果选择使用<code>new BigDecimal()</code>方法建立对象，括号内应该使用字符串形式而不是浮点型</p>
</li>
</ul>
</li>
<li><p>Date类</p>
<ul>
<li><p><code>SimpleDateFormat类</code></p>
<ul>
<li>可以把Date对象或者时间毫秒值格式化为我们想要的形式</li>
<li>也可以将字符串时间形式解析为日期对象</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th>方法||构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public Date()</code></td>
<td>创建一个Date对象，代表的是系统当前此刻日期时间</td>
</tr>
<tr>
<td><code>public long getTime()</code></td>
<td>获取当前时间的毫秒值</td>
</tr>
<tr>
<td><code>public Date(long time)</code></td>
<td>将时间毫秒值转换成Date日期对象</td>
</tr>
<tr>
<td><code>public void setTime(long time)</code></td>
<td>设置日期对象的时间为当前时间毫秒值对应的时间</td>
</tr>
</tbody></table>
</li>
<li><p>获取时间毫秒值</p>
<ul>
<li><strong>创建日期对象，获取时间毫秒值</strong></li>
<li>Date date &#x3D; new Date();</li>
<li>Long time &#x3D; date.getTime();</li>
<li><strong>毫秒值恢复成日期对象</strong></li>
<li>Date d &#x3D; new Date(time);</li>
<li>d.setTime(time);</li>
</ul>
</li>
</ul>
</li>
<li><p>包装类</p>
<ul>
<li>包装类是八种基本数据类型所对应的引用类型</li>
<li>集合和泛型也只支持包装类型，不支持基本数据类型</li>
<li>自动装箱：基本类型的数据和变量可以直接赋给包装类型的变量</li>
<li>自动拆箱：包装类型的变量可以直接赋给基本数据类型的变量</li>
<li><strong>可以将字符串类型的数值转换成真实的数据类型</strong></li>
<li><code>Integer.parseInt(&quot;字符串类型的整数&quot;)</code></li>
<li><strong><code>Integer.valueOf(&quot;&quot;)</code></strong></li>
</ul>
</li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式可以用一些规定的字符来制定规则，校验数据的合法性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/exp.png"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public String replaceAll(String regex, String newStr)</code></td>
<td>按照正则表达式匹配的内容进行替换</td>
</tr>
<tr>
<td><code>public String[] split(String regex)</code></td>
<td>按照正则表达式匹配的内容进行分割字符串，返回字符串数组</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待爬取字符串</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;dsad@@@ffsfddsd###feff@wddw_@@@fff&quot;</span>;</span><br><span class="line">      <span class="comment">//定义爬取规则，字符串形式</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\w&#123;3,5&#125;&quot;</span>;</span><br><span class="line">      <span class="comment">//将爬取编译成匹配对象</span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">      <span class="comment">//得到内容匹配器对象</span></span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line">      <span class="comment">//开始爬取</span></span><br><span class="line">      <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> matcher.group();</span><br><span class="line">          System.out.println(rs1);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Array类"><a href="#Array类" class="headerlink" title="Array类"></a>Array类</h1><p>数组操作工具类，专门用于操作数组元素</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static String toString(类型[] a)</code></td>
<td>返回字符串</td>
</tr>
<tr>
<td><code>public static void sort(类型[] a)</code></td>
<td>对数组默认进行升序排序</td>
</tr>
<tr>
<td><code>public static&lt;T&gt; void sort(类型[] a, Comparator&lt;? super T&gt; c)</code></td>
<td>使用比较器对象自定义排序</td>
</tr>
<tr>
<td><code>public static int binarySearch(int[] a, int key)</code></td>
<td>二分搜索数据中的数据（数组应提前排好序），存在返回索引，不存在返回不存在的元素应该插入的位置的负数-1</td>
</tr>
</tbody></table>
<ul>
<li><p>默认如果认为左边数据大于右边数据，则返回正整数</p>
</li>
<li><p>左边数据小于右边数据，返回负整数，相等则返回0</p>
</li>
<li><p>使用自定义时被排序的数组必须是引用类型的元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        Integer[] a = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">58</span>, <span class="number">6</span>, <span class="number">98</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认升序排列</span></span><br><span class="line"><span class="comment">//        Arrays.sort(a);</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(a));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用自定义比较器</span></span><br><span class="line">        Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="comment">//return o1 - o2; 升序</span></span><br><span class="line">                <span class="keyword">return</span> o2 - o1;<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>简化匿名内部类的代码写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">   被重写方法具体的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法形式，只能简化接口中只有一个抽象方法的匿名内部类形式</li>
<li>会加上<code>@FunctionalInterface</code>注解，表示接口必须是函数式接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">58</span>, <span class="number">6</span>, <span class="number">98</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义比较器</span></span><br><span class="line">Arrays.sort(a,  (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Lambda表达式省略写法<ul>
<li>参数类型可以省略不写</li>
<li>如果只有一个参数，参数类型可省略，()也可以省略</li>
<li>如果Lambda只有一行代码，可以省略大括号和分号</li>
<li>如果Lambda只有一行代码，可以省略大括号不写，如果是return语句，省略return同时也必须省略’;’</li>
</ul>
</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><p>集合类体系结构</p>
<ul>
<li>Collection单列集合，每个元素（数据）只包含一个值</li>
<li>Map双列集合，每个元素包含两个值（键值对）</li>
<li>集合都是支持泛型的，可在编译阶段约束集合只能操作某种数据类型</li>
<li>集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象</li>
</ul>
</li>
<li><p>Collection集合</p>
<ul>
<li><p>Collection的功能是全部单列集合都可以继承使用的</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean add(E e)</code></td>
<td>添加</td>
</tr>
<tr>
<td><code>public void clean()</code></td>
<td>清空</td>
</tr>
<tr>
<td><code>public boolean remove(E e)</code></td>
<td>删除指定元素</td>
</tr>
<tr>
<td><code>public boolean contains(Object obj)</code></td>
<td>判断当前集合是否包含给定元素</td>
</tr>
<tr>
<td><code>public boolean isEmpty()</code></td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td><code>public int size()</code></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><code>public Object[] toArray()</code></td>
<td>将集合中的元素存储到数组中</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Collection集合遍历</p>
<ul>
<li><strong><code>Iterator()</code>迭代器：</strong></li>
<li>获取：<code>Iterator&lt;E&gt; iterator()</code></li>
<li>方法：<code>boolean hasNext()</code>    <code>E next()</code></li>
<li>迭代器如果取元素越界将出现<code>NoSuchElementException</code>异常</li>
<li><strong><code>foreach/增强for循环</code></strong></li>
<li>既可以遍历数组也可以遍历循环，其内部原理也是一个Iterator迭代器</li>
<li><strong>格式：<code>for(元素数据类型 变量名:数组或者Collection集合)&#123;&#125;</code></strong></li>
<li><strong>Lambda表达式遍历集合</strong></li>
<li><code>lists.forEach(s -&gt; &#123;System.out.println(s)&#125;)</code></li>
</ul>
</li>
</ul>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h4 id="红黑规则"><a href="#红黑规则" class="headerlink" title="红黑规则"></a>红黑规则</h4><ul>
<li>每个节点为黑或者红，根节点必须是黑色</li>
<li>如果一个节点没有子节点或者父节点，该节点响应的指针属性值为nil，nil视为叶节点，叶节点为黑色</li>
<li>某一节点是红色，则子节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><strong>父节点为红色，叔叔节点也为红色</strong></p>
<ul>
<li>将父节点设为黑色，叔叔节点设为黑色</li>
<li>祖父节点也设为红色</li>
<li>如果祖父节点为根节点，则将根节点再次变成黑色</li>
</ul>
<p><strong>父节点为红色，叔叔节点为黑色</strong></p>
<ul>
<li>将父节点设为黑色</li>
<li>祖父节点设为红色</li>
<li>以祖父节点为支点进行旋转</li>
</ul>
<h1 id="List系列集合"><a href="#List系列集合" class="headerlink" title="List系列集合"></a>List系列集合</h1><p><strong>List特有方法：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void add(int index, E element)</code></td>
<td>指定位置插入特定元素</td>
</tr>
<tr>
<td><code>E remove(int index)</code></td>
<td>删除指定位置元素</td>
</tr>
<tr>
<td><code>E set(int index, E element)</code></td>
<td>修改指定位置元素</td>
</tr>
<tr>
<td><code>E get(int index)</code></td>
<td>返回指定位置元素</td>
</tr>
</tbody></table>
<ul>
<li>ArrayList基于数组实现，第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型：可以在编译阶段约束操作的数据类型，并进行检查</p>
<p>格式：&lt;数据类型&gt;</p>
<p>集合体系的全部接口和实现类都是支持泛型使用的</p>
<ul>
<li><p><strong>泛型类</strong></p>
<ul>
<li>定义类时同时定义了泛型的类就是泛型类</li>
<li>格式：修饰符 class 类名&lt;泛型变量&gt;{}</li>
</ul>
</li>
<li><p><strong>泛型方法</strong></p>
<ul>
<li>定义方法的同时定义了泛型的方法就是泛型方法</li>
<li>格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</li>
<li>方法中可以使用泛型接收一切实际类型的参数，方法更具通用性</li>
</ul>
</li>
<li><p><strong>泛型接口</strong></p>
<ul>
<li>使用泛型定义的接口</li>
<li>修饰符 interface 接口名称&lt;泛型变量&gt;{}</li>
</ul>
</li>
<li><p><strong>通配符：？</strong></p>
<ul>
<li>？可以在定义泛型的时候使用</li>
<li><code>? extends Car</code>：？必须是Car的子类或Car，泛型上限</li>
<li><code>？super Car</code>：？必须是Car或者其父类，泛型下限</li>
</ul>
</li>
</ul>
<h1 id="Set系列集合"><a href="#Set系列集合" class="headerlink" title="Set系列集合"></a>Set系列集合</h1><p><strong>无序、不重复、无索引</strong></p>
<ul>
<li>HashSet：无序，不重复，无索引</li>
<li>LinkedHashSet：有序，不重复，无索引</li>
<li>TreeSet：排序、不重复、无索引</li>
<li><strong>HashSet集合底层采用哈希表存储数据</strong></li>
</ul>
<p><strong>哈希值：JDK根据对象的地址，按照某种规则算出来的int类型的数值</strong></p>
<p><code>public int hashCode()</code>：返回对象的哈希值</p>
<ul>
<li>同一个对象返回的哈希值相同</li>
<li>默认情况下，不同对象的哈希值不同</li>
<li><strong>底层原理：JDK8之前，采用数组＋链表，8之后，当链表元素过多时将转换为红黑树，底层采用数组+链表+红黑树的形式</strong></li>
</ul>
<p><strong>哈希表流程：</strong></p>
<ul>
<li>创建一个默认长度为16，加载因为0.75的数组</li>
<li>根据哈希值跟数组长度计算存入位置</li>
<li>判断当前位置是否为null，是则直接存入，不是则比较属性值，一样则不存，不一样则存入数组</li>
<li>数组存满16*0.75&#x3D;12时，自动扩容，每次扩容原先两倍</li>
</ul>
<p><strong>LinkedHashSet集合底层基于哈希表，使用双链表记录添加顺序</strong></p>
<p><strong>TreeSet集合底层基于红黑树的数据结构实现排序</strong></p>
<ul>
<li>TreeSet集合存储对象的时候有两种方式可以设计自定义比较规则<ul>
<li>让自定义类实现<code>Comparable</code>接口重写里面的<code>compareTo</code>方法来制定比较规则</li>
<li><code>TreeSet</code>集合有参数构造器，可以设置<code>Comparator</code>接口对应的比较器对象，来定制比较规则</li>
<li><code>TreeSet</code>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Apple</span> <span class="variable">apple1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;111&quot;</span>, <span class="number">12.8</span>, <span class="number">120</span>);</span><br><span class="line">    <span class="type">Apple</span> <span class="variable">apple2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;222&quot;</span>, <span class="number">15.6</span>, <span class="number">560</span>);</span><br><span class="line">    <span class="type">Apple</span> <span class="variable">apple3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;333&quot;</span>, <span class="number">3.9</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;? <span class="built_in">super</span> Apple&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getWeight() - o2.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    treeSet.add(apple1);</span><br><span class="line">    treeSet.add(apple2);</span><br><span class="line">    treeSet.add(apple3);</span><br><span class="line"></span><br><span class="line">    System.out.println(treeSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li>可变参数用在形参中接收多个数据</li>
<li>可变参数格式：数据类型…参数名称</li>
<li>传输参数灵活，可以不传参数，可以传1个或者多个，也可以传输一组数据</li>
<li>可变参数在方法内部本质就是一个数组</li>
<li><strong>一个形参列表中可变参数只能有一个，可变参数必须放在形参列表的最后</strong></li>
</ul>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><ul>
<li>Map集合是一种双列集合，每个元素包含两个数据</li>
<li>Map集合元素格式：key&#x3D;value(键值对元素)</li>
<li>Map集合也称为键值对集合</li>
<li><strong>Map集合的键无序，不重复；Map集合的值不做要求，可以重复</strong></li>
<li><code>HashMap</code>：元素按照键是无序，不重复，无索引，值不做要求，与Map体系一致</li>
<li><code>LinkedHashMap</code>：元素按照键是有序，不重复，无索引，值不做要求</li>
<li><code>TreeMap</code>：元素按照键是排序，不重复，无索引的，值不做要求</li>
</ul>
<p><strong>常用API(Map API)</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V put(K key, V value)</code></td>
<td>添加元素</td>
</tr>
<tr>
<td><code>V remove(Object key)</code></td>
<td>删除元素</td>
</tr>
<tr>
<td><code>void clear()</code></td>
<td>移除所有元素</td>
</tr>
<tr>
<td><code>boolean containsKey(Object key)</code></td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td><code>boolean containsValue(Object value)</code></td>
<td>判断是否包含指定的值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><code>int size()</code></td>
<td>集合长度</td>
</tr>
</tbody></table>
<p><strong>Map集合遍历方式</strong></p>
<p><strong>键找值</strong></p>
<ol>
<li>获取Map集合的全部键的Set集合</li>
<li>遍历键的Set集合，通过键提取对应值</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set&lt;K&gt; KeySet()</code></td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td><code>V get(Object key)</code></td>
<td>根据键获取值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;2&quot;</span>, <span class="number">236</span>);</span><br><span class="line">    map.put(<span class="string">&quot;3&quot;</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = map.keySet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s: set)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(s);</span><br><span class="line">        System.out.println(s +<span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>键值对</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td><code>K getKey()</code></td>
<td>获得键</td>
</tr>
<tr>
<td><code>V getValue()</code></td>
<td>获得值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="number">236</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">    System.out.println(key + <span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v) -&gt; &#123;</span><br><span class="line">    System.out.println(k + <span class="string">&quot;===&gt;&quot;</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>创建不可变集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = List.of(<span class="number">12.5</span>, <span class="number">15.9</span>, <span class="number">12.4</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p><strong>Stream流的三类方法：</strong></p>
<ul>
<li>获取Stream流：创建一条流水线，将数据放到流水线上进行操作</li>
<li>中间方法：一次操作完毕后，还可以继续进行其他操作</li>
<li>终结方法：一个Stream流只能有一个终结方法，是流水线上最后一个操作</li>
</ul>
<p>获取方式：</p>
<ul>
<li>集合可以直接获取stream流</li>
<li>Map可以可通过获取键流或直流或者调用Entry获取键值对流</li>
<li>数组调用<code>Arrays.stream()</code>方法获取</li>
</ul>
<p><strong>常用API</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td>用于对流中的数据进行过滤</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; limit(long maxSize)</code></td>
<td>获取前几个元素</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; skip(long n)</code></td>
<td>跳过前几个元素</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; distinct()</code></td>
<td>去除流中重复的元素</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)</code></td>
<td>合并a、b流为一个流</td>
</tr>
<tr>
<td><code>void forEach(Consumer action)</code></td>
<td>对此流的每个元素进行遍历操作</td>
</tr>
<tr>
<td><code>long count()</code></td>
<td>返回此流中的元素数</td>
</tr>
</tbody></table>
<ul>
<li>map加工方法：第一个参数原材料 -&gt; 第二个参数为加工后的结果</li>
<li><code>list.stream().map(s -&gt; &quot;附加内容&quot; + s)</code></li>
<li>在Stream流中无法直接修改集合、数组中的元素</li>
</ul>
<p><strong>Stream流收集操作</strong></p>
<p>将stream流操作后的结果数据转回到集合或者数组当中</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>R collect(Collector collector)</code></td>
<td>开始收集stream流，指定收集器</td>
</tr>
<tr>
<td><code>public static &lt;T&gt; Collector toList()</code></td>
<td>把元素收集到List集合当中</td>
</tr>
<tr>
<td><code>public static &lt;T&gt; Collector toSet()</code></td>
<td>将元素收集到Set集合当中</td>
</tr>
<tr>
<td><code>public static Collector toMap(Function keyMapper, Function valueMapper)</code></td>
<td>把元素收集到Map集合当中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).distinct();</span><br><span class="line">    List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String k:</span><br><span class="line">         list1) &#123;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常程序指在编译或者执行时出现的问题，如数组越界、空指针异常、日期格式化异常，语法错误不算在异常体系内</p>
<ul>
<li><strong>Error：</strong>系统级别问题</li>
<li><strong>Exception：</strong>java.lang包下，称为异常类，表示程序本身可以处理的问题<ul>
<li><code>RuntimeException</code>及其子类：运行时异常，编译阶段不会报错（空指针异常，数组越界）</li>
<li>除<code>RuntimeException</code>之外的所有异常：编译时异常，编译期必须处理，否则程序不能通过编译。（日期格式化异常）</li>
</ul>
</li>
</ul>
<p><strong>运行异常：直接继承自RuntimeException或者子类</strong></p>
<ul>
<li>数组越界异常：<code>ArrayIndexOutOfBoundsException</code></li>
<li>空指针异常：<code>NullPointerException</code></li>
<li>数学操作异常：<code>ArithmeticException</code></li>
<li>类型转换异常：<code>ClassCastException</code></li>
<li>数字转换异常：<code>NumberFormatException</code></li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><p><code>throws</code>：用在方法上，将方法内部的异常抛出去给本方法的调用者处理</p>
</li>
<li><p><code>try...catch...</code>：监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理，发生异常的方法自己独立完成异常处理，程序可以继续往下执行</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Exception可以捕获处理一切异常类型</p>
<ul>
<li>方式三：方法直接将异常通过throws抛出去给调用者，调用者收到异常后处理异常</li>
</ul>
<p>在开发中底层的异常抛出去给最外层，最外层集中捕获处理使用较多</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>可以将系统执行的信息选择性的记录到指定位置，可以随时以开关的形式控制是否记录日志</p>
<h2 id="Logback日志框架"><a href="#Logback日志框架" class="headerlink" title="Logback日志框架"></a>Logback日志框架</h2><ul>
<li>slf4j-api：日志规范</li>
<li>logback-core：基础模块</li>
<li>logback-classic：是log4j的一个改良版本，同时完整实现了slf4j API</li>
</ul>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean isDirectory()</code></td>
<td>测试此抽象路径名表示的FIle是否为文件夹</td>
</tr>
<tr>
<td><code>public boolean isFile()</code></td>
<td>测试路径名表示的File是否为文件</td>
</tr>
<tr>
<td><code>public boolean exists()</code></td>
<td>测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td><code>public String getAbsolutePath()</code></td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td><code>public String getPath()</code></td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td><code>public String getName()</code></td>
<td>返回由此抽象路径名表示的文件或文件夹名称</td>
</tr>
<tr>
<td><code>public long lastModified()</code></td>
<td>返回文件最后修改的毫秒值</td>
</tr>
</tbody></table>
<p><strong>创建与删除</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean createNewFile()</code></td>
<td>创建一个新的空的文件</td>
</tr>
<tr>
<td><code>public boolean mkdir()</code></td>
<td>只能创建一级文件夹</td>
</tr>
<tr>
<td><code>public boolean mkdirs()</code></td>
<td>可以创建多级文件夹</td>
</tr>
<tr>
<td><code>public boolean delete()</code></td>
<td>删除由此抽象路径名表示的文件或者空文件夹</td>
</tr>
</tbody></table>
<p>delete方法是不走回收站的，只能删空文件夹，不能删非空文件夹</p>
<p><strong>遍历文件夹</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public String[] list()</code></td>
<td>获取当前目录下所有一级文件名称到i一个字符串数组中去返回</td>
</tr>
<tr>
<td><code>public File[] listFiles()</code></td>
<td>获取当前目录下所有一级文件对象到一个文件对象数组中去返回（常用）</td>
</tr>
</tbody></table>
<p><strong>listFiles：</strong></p>
<ul>
<li>当调用者不存在或者是一个文件时，返回null</li>
<li>当调用者是一个空文件时，返回一个长度为0的数组</li>
<li>当调用者是一个有内容的文件夹时，将里面的所有文件和文件夹的路径放在File数组中返回</li>
</ul>
<p><strong>递归文件搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;aDrive.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            searchFile(dir, fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.isFile() &amp;&amp; dir.getName().equals(fileName)) &#123;</span><br><span class="line">            System.out.println(dir.getAbsoluteFile());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir.isDirectory() &amp;&amp; dir != <span class="literal">null</span>) &#123;</span><br><span class="line">            File[] files = dir.listFiles();</span><br><span class="line">                <span class="keyword">for</span> (File file : files</span><br><span class="line">                ) &#123;</span><br><span class="line">                    searchFile(file, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte[] getBytes()</code></td>
<td>使用默认字符集将其编码为一系列字节并存储到数组中</td>
</tr>
<tr>
<td><code>byte[] getBytes(String charsetName)</code></td>
<td>使用指定字符集将其编码为一系列字节并存储到数组中</td>
</tr>
<tr>
<td><code>String(byte[] bytes)</code></td>
<td>使用默认字符集构造新的String</td>
</tr>
<tr>
<td><code>String(byte[] bytes, String charsetName)</code></td>
<td>通过指定字符集解码指定的字符数组构造新的String</td>
</tr>
</tbody></table>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/IOStream.png"></p>
<p>文件输入流：<code>FileInputStream</code></p>
<ul>
<li><p>以内存为基准，将磁盘文件中的数据按字节形式读取到内存</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public int read()</code></td>
<td>每次读取一个字节返回，读完则返回-1</td>
</tr>
<tr>
<td><code>public int read(byte[] buffer)</code></td>
<td>读取一个字节数组返回，字节没有可读返回-1</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public byte[] readAllBytes() throws IOException</code></td>
<td>直接将当前字节输入流对应的文件对象的字节数据撞到一个字节数组返回</td>
</tr>
</tbody></table>
</li>
</ul>
<p>文件输出流：<code>FileOutStream</code></p>
<ul>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public void write(int a)</code></td>
<td>写一个字节出去</td>
</tr>
<tr>
<td><code>public void write(byte[] buffer)</code></td>
<td>写一个字节数组出去</td>
</tr>
<tr>
<td><code>public void write(byte[] buffer, int pos, int len)</code></td>
<td>写一个字节数组的一部分</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flush()</code></td>
<td>刷新流</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭流，释放资源</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>文件拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./pre.txt&quot;</span>);</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./copy.txt&quot;</span>);</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./pre.txt&quot;</span>);</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./copy.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>JDK7以及9try中的()只能放置资源对象，<strong>资源都是实现了Closeable&#x2F;AutoCloseable接口的类对象</strong></p>
<p><strong>文件字符输入流：<code>FileReader</code></strong>,以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public FileReader(File file)</code></td>
<td>创建字符输入流管道与源文件对象接通</td>
</tr>
<tr>
<td><code>public FileReader(String pathname)</code></td>
<td>创建字符输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public int read</code></td>
<td>读取一个字符返回，没有则返回-1</td>
</tr>
<tr>
<td><code>public int read(char[] buffer)</code></td>
<td>每次读取一个字符组，返回读取的字符的个数，如果字符已经没有可读的则返回-1</td>
</tr>
</tbody></table>
<p>**文件字符输出流：<code>FileWriter</code>**，使用<code>write()</code>方法</p>
<p><strong>写入操作完成后需进行<code>flush()</code>刷新或<code>close()</code>关闭，关闭包含刷新，但是刷新后流可以继续使用</strong></p>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>缓冲流自带缓冲区，可以提高原始字节流，字符流读写数据的性能</p>
<p>字节缓冲输入流：<code>BufferedInputStream</code></p>
<p>字节缓冲输出流：<code>BufferedOutputStream</code></p>
<p><strong>字节缓冲流自带8KB缓冲池</strong></p>
<p>字符缓冲输入流：<code>BufferedReader</code></p>
<p>字符缓冲输出流：<code>BufferedWriter</code></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public BufferedInputStream(InputStream is)</code></td>
<td>把字节输入流包装成缓冲字节输入管道流，提高字节输入流读数据的性能</td>
</tr>
<tr>
<td><code>public BufferedOutputStream(OutputStream os)</code></td>
<td>把低级的字节输出流包装成一个高级的缓冲字节输出流，提高写数据的性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public BufferedReader(Reader r)</code></td>
<td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，提高字符输入流读数据的性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public String readLine()</code></td>
<td>读取一行数据返回，无行可读返回null</td>
</tr>
</tbody></table>
<p><strong>缓冲输出流</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public BufferedWriter(Writer w)</code></td>
<td>把字符输出流包装成缓冲字符输出流管道</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>新方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public void newLine()</code></td>
<td>换行操作</td>
</tr>
</tbody></table>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>字符输入转换流：<code>InputStreamReader</code>解决字符流读取不同编码乱码问题,<code>public InputStreamReader(InputStream is, String charset)</code>，可以指定编码把原始字节流转换为字符流，如此字符流中的字符不乱码</p>
<p>字符输出转换流：<code>public OutputStreamWriter(OutputStream os, String charset)</code></p>
<h3 id="对象序列化与反序列化"><a href="#对象序列化与反序列化" class="headerlink" title="对象序列化与反序列化"></a>对象序列化与反序列化</h3><p>以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化，使用到的流为字节输出流<code>ObjectOutputStream</code></p>
<p><code>transient</code>修饰的成员变量不再参与序列化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public ObjectOutputStream(OutputStream out)</code></td>
<td>把低级字节输出流包装成高级的对象字节输出流</td>
</tr>
</tbody></table>
<p>使用<code>writeObject()</code>写入对象</p>
<p><strong>对象如果要实现序列化，一定要实现Serializable接口！！！</strong></p>
<p>以内存为基准，把存储到磁盘文件中的对象数据恢复成内存中的对象，称为反序列化</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public ObjectInputStream(InputStream out)</code></td>
<td>把低级字节输入流包装成高级的对象字节输入流</td>
</tr>
</tbody></table>
<p>使用<code>readObject</code>读入对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> saveObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">write</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, <span class="number">15</span>, <span class="string">&quot;boy&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lisi&quot;</span>, <span class="number">98</span>, <span class="string">&quot;girl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./Student_message.txt&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            oos.writeObject(student1);</span><br><span class="line">            oos.writeObject(student2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> saveObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">read</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Student_message.txt&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">            System.out.println(student1);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">            System.out.println(student2);</span><br><span class="line">            System.out.println(ois.readObject());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指<code>PrintStream</code>,<code>PrintWriter</code></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public PrintStream(OutputStream os)</code></td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td><code>pubilc PrintStream(File f)</code></td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td><code>public PrintStream(String filepath)</code></td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public void print(XXXX)</code></td>
<td>打印任意类型的数据出去</td>
</tr>
</tbody></table>
<p><code>PrintWriter</code>功能与<code>PrintStream</code>相同，但是其属于字符输出流</p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void load(Reader reader)</code></td>
<td>从输入字符流读取属性列表</td>
</tr>
<tr>
<td><code>void store(Writer writer, String comments)</code></td>
<td>将属性列表写入此Properties表，适合使用<code>load(Reader)</code>方法的格式写入输出字符流</td>
</tr>
<tr>
<td><code>public String getProperty(String key)</code></td>
<td>使用此属性列表中指定的键搜索属性值</td>
</tr>
<tr>
<td><code>public Object setProperty(String key, String value)</code></td>
<td>保存键值对(put)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hashStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;15&quot;</span>,<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;18&quot;</span>,<span class="string">&quot;joker&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;17&quot;</span>,<span class="string">&quot;Sari&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key:</span><br><span class="line">             set) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            properties.setProperty(key,value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;./store_map.properties&quot;</span>),<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;./store_map.properties&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是一个程序内部的一条执行路径，启动程序后，main方法的执行其实就是一条单独的执行路径</p>
<p><strong>创建方式一：</strong></p>
<ol>
<li>定义一个子类继承java.lang.Thread，重写run()方法</li>
<li>创建线程对象</li>
<li>调用线程对象的<code>start()</code>方法启动线程（启动后还是执行<code>run()</code>方法）</li>
</ol>
<p>编码简单，但是已经继承<code>Thread()</code>，无法继承其他类，不利于扩展</p>
<p>如果直接调用<code>run()</code>方法则会当成普通方法执行，即单线程执行</p>
<p>应该将子线程放于主线程之前，否则主线程先跑完达不到多线程的效果</p>
<p><strong>创建方式二：实现<code>Runnable</code>接口</strong></p>
<ol>
<li>定义一个线程任务类实现<code>Runnable</code>接口，重写<code>run()</code>方法</li>
<li>创建任务对象</li>
<li>把任务对象交给Thread处理</li>
<li>调用<code>start()</code>方法启动线程</li>
</ol>
<p>优点：实现接口，可以继承类和实现其他接口，可扩展性强</p>
<p>缺点：线程有执行结果无法返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用匿名内部类直接实现</p>
<p><strong>实现方法三：用<code>Callable</code>、<code>FutureTask</code>接口实现</strong></p>
<ol>
<li><p>得到任务对象</p>
<ul>
<li>定义类实现<code>Callable</code>接口，重写call方法</li>
<li>用<code>FutureTask</code>把<code>Callable</code>对象封装成线程任务对象</li>
</ul>
</li>
<li><p>把线程任务对象交给Thread处理</p>
</li>
<li><p>调用Thread的<code>start()</code>方法启动线程，执行任务</p>
</li>
<li><p>线程执行完毕，使用<code>FutureTask</code>的get方法获取任务执行的结果</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">5</span>);</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n &lt; <span class="number">10</span>; n++) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程输出结果：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String getName()</code></td>
<td>获取当前线程名称，默认线程名称Thread-索引</td>
</tr>
<tr>
<td><code>void setName(String name)</code></td>
<td>将线程名称更改为指定的名称，通过构造器也可以设置线程名称</td>
</tr>
</tbody></table>
<p>通过<code>Thread.currentThread().getName()</code>判断出当前在执行的线程的名称</p>
<p>线程休眠方法：<code>public static void sleep(long time)</code>，让当前线程休眠指定时间后再继续执行，单位为毫秒</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>加锁：让多个线程实现先后依次访问共享资源，解决线程安全问题</p>
<p><strong>同步代码块：</strong></p>
<p>作用：把出现线程安全问题的核心代码上锁</p>
<p>原理：每次只能有一个线程进入，执行完毕后解锁之后才能允许其他线程进入</p>
<p><strong>锁对象应该使用共享资源作为锁对象，而不应该任意选择，对于实例方法建议使用this作为锁对象，对于静态方法建议使用字节码（类型.class）对象作为锁对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCash</span><span class="params">(<span class="type">int</span> take)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cash &gt;= take) &#123;</span><br><span class="line">            cash -= take;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running and the cash rest is &quot;</span>+ cash);</span><br><span class="line">            <span class="keyword">return</span> cash;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;cash is not enough!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步方法：</strong></p>
<p>把出现线程安全问题的核心方法上锁，每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以执行</p>
<p>使用<code>synchronized</code>直接修饰方法即可</p>
<ul>
<li>同步方法其实底层也有隐式锁对象，只是锁的范围是整个方法代码</li>
<li>如果方法是实例方法，同步方法默认使用this作为锁对象，但是代码要高度面向对象</li>
<li>如果方法是静态方法，同步方法默认用类名.class作为锁对象</li>
</ul>
<p><strong>Lock锁：</strong></p>
<p><code>private final ReentrantLock lock = new ReentrantLock()</code>,使用<code>lock.lock()</code>上锁，使用<code>lock.unlock()</code>解锁。</p>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>void wait()</code></td>
<td>让当前线程等待并释放所占锁，直到另一个线程调用<code>notify()</code>方法或<code>notifyAll()</code>方法</td>
</tr>
<tr>
<td><code>void notify()</code></td>
<td>唤醒正在等待的单个线程</td>
</tr>
<tr>
<td><code>void notifyAll()</code></td>
<td>唤醒正在等待的所有线程</td>
</tr>
</tbody></table>
<p><strong>上述方法应该使用当前同步锁对象进行调用！</strong></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是一个可以复用线程的技术</p>
<p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建线程，而创建新线程开销太大，会影响系统性能，因此引入线程池</p>
<p>线程池接口：<code>ExcutorService</code>，</p>
<p>方法一：可以使用其实现类<code>ThreadPoolExcutor</code>自创建一个线程池对象</p>
<p>方法二：使用<code>Executors</code>（线程池的工具类）调用方法返回不同特点的线程池对象</p>
<p><strong>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程时，才会创建临时线程</strong></p>
<p><strong>核心线程和临时线程都在忙，任务队列也满了，此时若有新的任务过来才会开始任务拒绝</strong></p>
<p>任务拒绝策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadPoolExecutor.AbortPolicy</code></td>
<td>丢弃任务并抛出RejectedExecutionException异常，是默认策略</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor.DiscardPolicy</code></td>
<td>丢弃任务，但是不抛出异常</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor.DiscardOldestPolicy</code></td>
<td>抛弃队列中等待最久的任务，然后把当前任务加入队列</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor.CallerRunsPolicy</code></td>
<td>由主线程负责调用任务的<code>run()</code>方法从而绕过线程池直接执行</td>
</tr>
</tbody></table>
<p><strong><code>ExecutorService</code>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void execute(Runnable command)</code></td>
<td>执行任务，没有返回值，一般用来执行runnable任务</td>
</tr>
<tr>
<td><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td>
<td>执行任务，返回未来任务对象获取线程结果，一般用来执行<code>Callable</code>任务</td>
</tr>
<tr>
<td><code>void shutdown()</code></td>
<td>等任务执行完毕后关闭线程池</td>
</tr>
<tr>
<td><code>List&lt;Runnable&gt; shutdownNow()</code></td>
<td>立刻关闭，停止正在执行的线程任务，并返回队列中的未执行任务</td>
</tr>
</tbody></table>
<p><strong>通过线程池创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ID&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public ThreadPoolExecutor( int corePoolSize,</span></span><br><span class="line"><span class="comment">    int maximumPoolSize,</span></span><br><span class="line"><span class="comment">    long keepAliveTime,</span></span><br><span class="line"><span class="comment">    TimeUnit unit,</span></span><br><span class="line"><span class="comment">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">    RejectedExecutionHandler handler)*/</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">myCallable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(account,<span class="number">500</span>);</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">myCallable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(account,<span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; future1 = threadPoolExecutor.submit(myCallable1);</span><br><span class="line">    Future&lt;Integer&gt; future2 = threadPoolExecutor.submit(myCallable2);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Excutors工具类实现线程池"><a href="#Excutors工具类实现线程池" class="headerlink" title="Excutors工具类实现线程池"></a><code>Excutors</code>工具类实现线程池</h3><p><code>Excutors</code>，线程池的工具类通过调用方法返回不同类型的线程池对象</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static ExecutorService newCachedThreadPool()</code></td>
<td>线程数量随着任务增加而增加，如果线程执行完毕且空闲了一段时间则会被回收</td>
</tr>
<tr>
<td><code>public static ExecutorService newFixedThreadPool(int nThreads)</code></td>
<td>创建固定数量的线程池，如果因为某个线程因为执行异常而结束，线程池将创建一个新的线程去替代它</td>
</tr>
<tr>
<td><code>public static ExecutorService newSingleThreadExcutor()</code></td>
<td>创建只有一个线程的线程池对象，如果该线程因为出现异常而结束，线程池会补充一个新的线程</td>
</tr>
<tr>
<td><code>public static ScheduledEexcutorService newScheduledThreadPool(int corePoolSize)</code></td>
<td>创建一个线程池，可以实现在给定的延迟之后运行任务或者定期执行任务</td>
</tr>
</tbody></table>
<p><strong>Excutors的底层也是基于线程池的实现类<code>ThreadPoolExecutor</code>创建线程池对象的</strong></p>
<p>在大型并发环境中使用工具类容易出现问题，建议自己创建线程池对象</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>一种控制任务延时调用或者周期调用的技术</p>
<p><strong>方式一：Timer定时器</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public Timer</code></td>
<td>创建Timer定时器对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public void schedule(TimerTask task, long delay, long period)</code></td>
<td>开启定时器，按照计划处理TimerTask任务</td>
</tr>
</tbody></table>
<p>可能存在的问题</p>
<ol>
<li>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入</li>
<li>可能因为其中某个任务的异常使得Timer线程死掉，影响后续任务执行</li>
</ol>
<p><strong>方式二：ScheduledExecutorService定时器</strong></p>
<table>
<thead>
<tr>
<th>Executors方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code></td>
<td>得到线程池对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>ScheduledExecutorService方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td>周期调度方法</td>
</tr>
</tbody></table>
<p>基于线程池，某个任务的执行情况不会影响其他定时任务的执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">clock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span>  Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;is running now&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>正在运行的程序就是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的</p>
<p>并发：CPU同时处理线程的数量有限，CPU会轮询为系统的每个线程服务，由于CPU的切换速度非常快，给我们感觉这些线程在同时执行，这就是并发</p>
<p>并行：在同一时刻上，同时有多个线程在被CPU处理并执行</p>
<p>线程六种状态：新建，就绪，阻塞，等待，计时等待，结束</p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>常见的通信模式有如下两种：Client-Server(CS)客户端服务端模式和Browser&#x2F;Server(BS)浏览器服务端模式</p>
<p>实现网络编程的三要素：IP地址，端口，协议</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li>IP全称“互联网协议地址”，是分配给上网设备的唯一标志</li>
<li>常见的IP分类为Ipv4（4字节，点分十进制表示法）和IPv6（16字节，号称可以为地球每一粒沙子编号，分为八个整数，每个整数用四个十六进制位表示，数之间用：隔开，即冒分十六进制表示法）</li>
</ul>
<h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a><code>InetAddress</code></h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static InetAddress getLocalHost()</code></td>
<td>返回本主机的地址对象</td>
</tr>
<tr>
<td><code>public static InetAddress getByName(String host)</code></td>
<td>得到指定主机的Ip地址对象，参数是域名或者IP地址</td>
</tr>
<tr>
<td><code>public String getHostName()</code></td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td><code>public String getHostAddress()</code></td>
<td>返回IP地址字符串</td>
</tr>
<tr>
<td><code>public boolean isReachable(int timeout)</code></td>
<td>在指定毫秒内连通该IP对应的主机，联通则返回true</td>
</tr>
</tbody></table>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>标识正在计算机设备上运行的程序，被规定位一个16位的二进制，范围是0~65535</p>
<p><strong>端口类型</strong></p>
<ul>
<li>周知端口：0~1023，被预先定义的知名应用占用（HTTP占用80，FTP占用21）</li>
<li>注册端口：1024~49151,分配给用户进程或某些用户程序（Tomcat占8080，MySQL占用3306）</li>
<li>动态端口：49152~65535，一般不固定分配某种进程，而是动态分配</li>
</ul>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>连接和通信数据的规则被称为网络通信协议</p>
<p>OSI参考模型：世界互联协议标准，全球通信规范，此模型过于理想化，未能在因特网上进行广泛推广</p>
<p>TCP&#x2F;IP参考模型（TCP&#x2F;IP协议）：事实上的国际标准</p>
<table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>TCP&#x2F;IP参考模型</th>
<th>各层对应</th>
<th>面向操作</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>前三层统称应用层</td>
<td>HTTP、FTP、DNS、SMTP</td>
<td>应用程序需要关注的：浏览器，邮箱。程序员一般在这层开发</td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP</td>
<td>选择使用的TCP、UDP协议</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP、ICMP</td>
<td>封装源和目标IP</td>
</tr>
<tr>
<td>数据链路层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理层</td>
<td>后两层统称物理层</td>
<td>物理寻址，比特流</td>
<td>物理设备中传输</td>
</tr>
</tbody></table>
<p>传输层两个常见协议：TCP（传输控制协议）和UDP（用户数据报协议）</p>
<p><strong>TCP协议特点</strong>：使用TCP协议，必须双方先建立连接，是一种面向连接的可靠通信协议</p>
<ul>
<li>传输前，采用“三次握手”方式建立连接，所以是可靠的</li>
<li>在连接中可进行大数据量的传输</li>
<li>连接发送数据都需要确认，且传输完毕后，还需要释放已经建立的连接，通信效率低</li>
<li>适用于对信息安全要求较高的场景，如文件下载，金融等数据通信</li>
</ul>
<p><strong>三次握手：</strong></p>
<ol>
<li>客户端向服务器发出连接请求，等待服务器确认</li>
<li>服务器向客户端返回一个响应，告诉客户端收到请求</li>
<li>客户端向服务器再次发出确认消息，连接建立</li>
</ol>
<p><strong>四次挥手断开连接</strong></p>
<ol>
<li>客户端向服务器发出取消连接请求</li>
<li>服务器向客户端返回一个响应，表示收到客户端取消请求</li>
<li>服务器将最后的数据处理完毕，向客户端发出确认取消信息</li>
<li>客户端再次发送确认消息，连接取消</li>
</ol>
<p><strong>UDP协议</strong></p>
<ul>
<li>UDP是一种无连接，不可靠传输的一种协议</li>
<li>将数据源IP、目的地IP、和端口封装成数据包，不需要建立连接</li>
<li>每个数据包大小限制在64KB内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送，发送数据结束时无需释放资源，开销小，速度快</li>
<li>适用于语音通话，视频会话等</li>
</ul>
<h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p>发送端和接收端对象：</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public DatagramSocket()</code></td>
<td>创建发送端的Socket对象，系统会随机分配一个端口号</td>
</tr>
<tr>
<td><code>public DatagramSocket(int port)</code></td>
<td>创建接收端的Socket对象并指定端口号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public void send(DatagramPacket dp)</code></td>
<td>发送数据包</td>
</tr>
<tr>
<td><code>public void receive(DatagramPacket p)</code></td>
<td>接收数据包</td>
</tr>
</tbody></table>
<p>DatagramPacket：数据包对象</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code></td>
<td>创建发送端数据包对象，buf：要发送的内容，length：长度，InetAddress：接收端的IP地址对象，port：接收端的端口号</td>
</tr>
<tr>
<td><code>public DatagramPacket(byte[] buf, int length)</code></td>
<td>创建接收端的数据包对象，buf：用来存储接收的内容，length：能够接收内容的长度</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public int getLength()</code></td>
<td>获得实际接收到的字节个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client_demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Sacrifice leads, and gains follow&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length, InetAddress.getLocalHost(),<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            datagramSocket.send(packet);</span><br><span class="line">            datagramSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server_demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;The server is running&quot;</span>);</span><br><span class="line">            datagramSocket.receive(datagramPacket);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>, datagramPacket.getLength());</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            datagramSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP实现广播：使用广播地址：255.255.255.255 </p>
<p>具体操作：</p>
<ol>
<li>发送端发送的数据包目的地写的是广播地址并且指定端口</li>
<li>本机所在网段的其他主机的程序只要匹配端口成功就可以收到消息了</li>
</ol>
<p>组播：使用组播地址：224.0.0.0 ~239.255.255.255</p>
<ol>
<li>发送端的数据包的目的地是组播IP（例如224.0.0.1，端口：9999）</li>
<li>接收端必须绑定该组播IP（224.0.1.1），端口还要对应发送端的目的端口9999，这样即可接收该组播消息</li>
<li><code>DatagramSocket</code>的子类<code>MulticastSocket</code>可以在接收端绑定组播IP</li>
</ol>
<h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public Socket(String host, int port)</code></td>
<td>创建发送端的Socket对象与服务端连接，参数为服务端程序的IP和端口</td>
</tr>
</tbody></table>
<p>Socket类成员方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>OutputStream getOutputStream()</code></td>
<td>获得字节输出流对象</td>
</tr>
<tr>
<td><code>InputStream getInputStream()</code></td>
<td>获得字节输入流对象</td>
</tr>
</tbody></table>
<p>ServerSocket(服务端)</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public ServerSocket(int port)</code></td>
<td>注册服务器端口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public Socket accept()</code></td>
<td>等待接收客户端的Socket通信连接，连接成功则返回Socket对象与客户端建立端到端通信</td>
</tr>
</tbody></table>
<p>服务端可以使用复用线程处理多个客户端，避免系统瘫痪</p>
<p>适合客户端通信时长较短的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReader</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Runnable &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReader</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">                System.out.println(socket.getLocalSocketAddress() + <span class="string">&quot; says: &quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="comment">/*public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">                              int maximumPoolSize,</span></span><br><span class="line"><span class="comment">                              long keepAliveTime,</span></span><br><span class="line"><span class="comment">                              TimeUnit unit,</span></span><br><span class="line"><span class="comment">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">                              RejectedExecutionHandler handler)*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器运行！&quot;</span>);</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getLocalSocketAddress() + <span class="string">&quot; online!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerReader</span>(socket);</span><br><span class="line">                pool.execute(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">7777</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;put in: &quot;</span>);</span><br><span class="line">                ps.println(scanner.nextLine());</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试就是针对最小的功能单元写测试代码，java程序的最小功能单元是方法，单元测试是针对Java方法的测试</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射是指对于任何一个Class类，在运行的时候都可以直接得到这个类的全部成分</p>
<ul>
<li><p>在运行时可以直接得到这个类的构造器对象：Constructor</p>
</li>
<li><p>在运行时可以直接得到这个类的成员变量对象：Field</p>
</li>
<li><p>在运行时可以直接得到这个类的成员变量方法：Method</p>
</li>
<li><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为JAVA语言的反射机制</p>
</li>
<li><p><strong>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分</strong></p>
</li>
</ul>
<h3 id="获取Class类的对象的三种方式"><a href="#获取Class类的对象的三种方式" class="headerlink" title="获取Class类的对象的三种方式"></a>获取Class类的对象的三种方式</h3><ol>
<li><code>Class c1 = Class.forName(&quot;全类名&quot;)</code></li>
<li><code>Class c2 = 类名.class</code></li>
<li><code>Class c3 = 对象.getClass()</code></li>
</ol>
<h3 id="反射获取构造器对象"><a href="#反射获取构造器对象" class="headerlink" title="反射获取构造器对象"></a>反射获取构造器对象</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Constructor&lt;?&gt;[] getConstructors()</code></td>
<td>返回所有构造器对象的数组（<strong>只能拿public的</strong>）</td>
</tr>
<tr>
<td><code>Constructor&lt;?&gt;[] getDeclaredConstructors</code></td>
<td>返回构造器对象的数组，存在就能拿到</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个构造器对象，<strong>只能拿public</strong></td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个构造器对象，存在就能拿到</td>
</tr>
</tbody></table>
<p><code>Constructor</code>类中用于创建对象的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T newInstance(Object... initargs)</code></td>
<td>根据指定的构造器创建对象</td>
</tr>
<tr>
<td><code>public void setAccessible(boolean flag)</code></td>
<td>设置为true，表示取消访问检查，进行暴力反射，可以直接调用私有构造器new对象</td>
</tr>
</tbody></table>
<h3 id="反射获取成员变量对象"><a href="#反射获取成员变量对象" class="headerlink" title="反射获取成员变量对象"></a>反射获取成员变量对象</h3><p>反射第一步是先得到类对象，然后从类对象中获取类的成分对象</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Field[] getFields()</code></td>
<td>返回所有成员变量对象的数组（只能拿public）</td>
</tr>
<tr>
<td><code>Field[] getDeclaredFields()</code></td>
<td>返回所有成员变量对象的数组，存在就能拿到</td>
</tr>
<tr>
<td><code>Field getField(String name)</code></td>
<td>返回单个成员变量对象（只能拿public的）</td>
</tr>
<tr>
<td><code>Field getDeclaredField(String name)</code></td>
<td>返回单个成员变量对象，存在就能拿到</td>
</tr>
</tbody></table>
<p>Field类中用于取值、赋值的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void set(Object obj, Object value)</code></td>
<td>赋值</td>
</tr>
<tr>
<td><code>Object get(Object obj)</code></td>
<td>获取值</td>
</tr>
</tbody></table>
<h3 id="反射获取方法对象"><a href="#反射获取方法对象" class="headerlink" title="反射获取方法对象"></a>反射获取方法对象</h3><p>先得到类对象，然后从类对象中获取类的成分对象</p>
<p>Class类中用于获取成员方法的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Method[] getMethods</code></td>
<td>返回所有成员方法对象的数组（只能拿public的）</td>
</tr>
<tr>
<td><code>Method[] getDeclaredMethods()</code></td>
<td>返回所有成员方法对象的数组，存在就能拿到</td>
</tr>
<tr>
<td><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个成员方法对象（只能拿public的）</td>
</tr>
<tr>
<td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个成员方法对象，存在就能拿到</td>
</tr>
</tbody></table>
<p>Method类中用于触发执行的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object invoke(Object obj, Object... args)</code></td>
<td>运行方法：参数一，用obj对象调用该方法；参数二：调用方法的传递的参数，没有则不写；返回值：方法的返回值，没有则不写</td>
</tr>
</tbody></table>
<h3 id="反射作用"><a href="#反射作用" class="headerlink" title="反射作用"></a>反射作用</h3><p><strong>绕过编译阶段为集合添加数据</strong></p>
<p>反射是作用在运行时的技术，此时集合的泛型将不能产生约束，此时是可以为集合存入其他任意类型的元素的</p>
<p><strong>通用框架的底层原理</strong></p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>对JAVA中类、成员变量、方法做标记，然后进行特殊处理，例如JUnit框架中标记了注解@Test的方法就可以被当成测试方法执行，没有标记则不能被当作测试方法执行</p>
<p><strong>自定义注解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    <span class="keyword">public</span> 属性类型 属性名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊属性：</p>
<ul>
<li>value属性，如果只有一个value属性的情况下，使用value属性的时候就可以省略value名称不写</li>
<li>如果有多个属性，且多个属性没有默认值，那么value名称是不能被省略的</li>
</ul>
<p><strong>元注解：</strong></p>
<p>元注解就是注解注解的注解</p>
<ul>
<li><code>@Target</code>：约束自定义注解只能在哪些地方使用</li>
<li><code>@Retention</code>：申明注解的生命周期</li>
</ul>
<p><code>@Target</code>中可以使用的值定义在ElementType枚举类中，常用值如下：</p>
<ul>
<li>TYPE,类，接口</li>
<li>FIELD，成员变量</li>
<li>METHOD，成员方法</li>
<li>PARAMETER,方法参数</li>
<li>CONSTRUCTOR，构造器</li>
<li>LOCAL_VARIABLE，局部变量</li>
</ul>
<p><code>@Retention</code>中可以使用的值在<code>RetentionPolicy</code>枚举类中，常用值如下</p>
<ul>
<li>SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在</li>
<li>CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值</li>
<li>RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</li>
</ul>
<p> <strong>注解解析</strong></p>
<p>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容</p>
<ul>
<li><code>Annotation</code>：注解的顶级接口，注解都是Annotation类型的对象</li>
<li><code>AnnotatedElement</code>：该接口定义了与注解解析相关的解析方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Annotation[] getDeclaredAnnotations</code></td>
<td>获得当前对象上使用的所有注解</td>
</tr>
<tr>
<td><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></td>
<td>根据注解类型获得对应注解对象</td>
</tr>
<tr>
<td><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; annotationClass)</code></td>
<td>判断当前对象是否使用了指定的注解，使用了则返回true，否则false</td>
</tr>
</tbody></table>
<p>所有的类的成分Class，Method，Field，Constructor都实现了AnnotatedElement接口，他们都拥有解析注释的能力</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>一个对象，用来对被代理对象的行为额外做一些辅助工作</p>
<p><strong>创建代理对象：</strong></p>
<ul>
<li>JAVA中代理的代表类是java.lang.reflect.Proxy</li>
<li>Proxt提供了一个静态方法，用于为对象产生一个代理对象返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br></pre></td></tr></table></figure>

<p>为对象返回一个代理对象</p>
<p>参数一：定义代理类的类加载器</p>
<p>参数二：代理类要实现的接口列表</p>
<p>参数三：将方法调用分派到的处理程序（代理对象的核心处理程序）</p>
<p><strong>实现动态代理要求：</strong></p>
<ul>
<li>必须存在接口</li>
<li>被代理对象需要实现接口</li>
<li>使用Proxy类提供的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Skill <span class="title function_">getProxy</span><span class="params">(star obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Skill) Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收首付款&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;收尾款&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> rs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">star</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">star</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Skill</span> <span class="variable">star_agent</span> <span class="operator">=</span> StarProxy.getProxy(star);</span><br><span class="line"></span><br><span class="line">        star_agent.sing();</span><br><span class="line">        star_agent.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML是可扩展标记语言（extensible Markup Language）的缩写，它是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据</p>
<ul>
<li>XML是纯文本，默认使用UTF-8编码，二是可嵌套</li>
<li>如果把XML内容存为文件，那么它就是一个XML文件</li>
<li>XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息</li>
</ul>
<p><strong>XML语法规则：</strong></p>
<ul>
<li>XML文件的后缀名：xml</li>
<li>文档声明必须置于第一行</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br></pre></td></tr></table></figure>

<p>XML标签规则：</p>
<ul>
<li>标签由一对尖括号和合法标识符组成，必须存在一个根标签，有且仅有一个</li>
<li>标签必须成对出现，有开始有结束</li>
<li>特殊的标签可以不成对，但是必须有结束标记，如<code>&lt;br/&gt;</code></li>
<li>标签可以自定义属性，属性和标签名空格隔开，属性值必须用引号引起来<code>&lt;student id = &quot;1&quot;&gt;&lt;/name&gt;</code></li>
<li>XML文件中也可以定义注释信息：<code>&lt;!- 注释内容 --&gt;</code></li>
</ul>
<p>XML存在以下特殊字符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&amp;gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&amp;amp;</code></td>
<td>和号</td>
</tr>
<tr>
<td><code>&amp;apos;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>&amp;quot;</code></td>
<td>双引号</td>
</tr>
</tbody></table>
<p>XML文件中可以存在CDATA区：<code>&lt;![CDATA[ ...内容... ]]&gt;</code></p>
<h3 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h3><p>DOM解析的文档对象模型</p>
<p>Document对象：整个xml文档</p>
<p>Element对象：标签</p>
<p>Attribute对象：属性</p>
<p>Text对象：文本内容</p>
<p>后三个都实现node接口</p>
<p>Dom4j解析XML</p>
<p>SAXReader类：</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>public SAXReader</code>()</td>
<td>创建DOM4j的解析器对象</td>
</tr>
<tr>
<td><code>Document read(String url)</code></td>
<td>加载XML文件成为Document对象</td>
</tr>
</tbody></table>
<p>Document类</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Element getRootElement()</code></td>
<td>获得根元素对象</td>
</tr>
</tbody></table>
<p>检索XML文件可以使用Xpath</p>
<p><strong>工厂模式：</strong></p>
<p>对象通过工厂的方法创建返回，工厂的方法可以为该对象进行加工和数据注入</p>
<p>可以实现类与类之间的解耦操作（核心思想）</p>
<p><strong>装饰模式：</strong></p>
<p>创建一个新类，包装原始类，从而在新类中提升原来类的功能</p>
<p>装饰模式指的是在不改变原来类的基础上，动态的扩展一个类的功能</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">yao chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/12/Java-SE/">http://example.com/2023/03/12/Java-SE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Joker's Warm Cabin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/back-end/">back-end</a></div><div class="post_share"><div class="social-share" data-image="/img/head_picture.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/10/MySQL/" title="MySQL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/05/%E5%85%B3%E4%BA%8EExpress/" title="关于Express"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于Express</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/18/Maven/" title="Maven"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">Maven</div></div></a></div><div><a href="/2023/04/25/Maven%E5%AE%8C%E6%95%B4%E7%89%88/" title="Maven完整版"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-25</div><div class="title">Maven完整版</div></div></a></div><div><a href="/2023/05/11/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-11</div><div class="title">SSM框架</div></div></a></div><div><a href="/2023/04/19/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" title="Web后端开发（初学）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-19</div><div class="title">Web后端开发（初学）</div></div></a></div><div><a href="/2023/04/19/%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/" title="关于响应状态码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-19</div><div class="title">关于响应状态码</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_picture.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yao chen</div><div class="author-info__description">故事要美必须藏着真话</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JOKER1515"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Irregular renewal.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IDEA%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">IDEA项目结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">进制表示形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaBean"><span class="toc-number">3.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8API"><span class="toc-number">4.</span> <span class="toc-text">String常用API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">ArrayList集合常用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">static静态关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">11.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">13.</span> <span class="toc-text">常用API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Array%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">Array类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">17.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">18.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E8%A7%84%E5%88%99"><span class="toc-number">18.0.0.1.</span> <span class="toc-text">红黑规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">18.0.0.2.</span> <span class="toc-text">插入</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">19.</span> <span class="toc-text">List系列集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">20.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">21.</span> <span class="toc-text">Set系列集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">23.</span> <span class="toc-text">Map集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">24.</span> <span class="toc-text">Stream流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">25.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">25.0.0.1.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">26.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Logback%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-number">26.1.</span> <span class="toc-text">Logback日志框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">27.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="toc-number">28.</span> <span class="toc-text">编码与解码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">29.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">29.0.1.</span> <span class="toc-text">缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">29.0.2.</span> <span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">29.0.3.</span> <span class="toc-text">对象序列化与反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">29.0.4.</span> <span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-number">29.0.5.</span> <span class="toc-text">Properties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">30.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">30.0.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">30.0.2.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">30.0.3.</span> <span class="toc-text">线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">30.0.4.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Excutors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">30.0.5.</span> <span class="toc-text">Excutors工具类实现线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">30.0.6.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">30.0.7.</span> <span class="toc-text">并发与并行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">31.</span> <span class="toc-text">网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">31.0.1.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress"><span class="toc-number">31.0.2.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">31.0.3.</span> <span class="toc-text">端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">31.0.4.</span> <span class="toc-text">通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="toc-number">31.0.5.</span> <span class="toc-text">UDP通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1"><span class="toc-number">31.0.6.</span> <span class="toc-text">TCP通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">32.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">33.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">33.0.1.</span> <span class="toc-text">获取Class类的对象的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">33.0.2.</span> <span class="toc-text">反射获取构造器对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">33.0.3.</span> <span class="toc-text">反射获取成员变量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">33.0.4.</span> <span class="toc-text">反射获取方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BD%9C%E7%94%A8"><span class="toc-number">33.0.5.</span> <span class="toc-text">反射作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">34.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">35.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XML"><span class="toc-number">36.</span> <span class="toc-text">XML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E8%A7%A3%E6%9E%90"><span class="toc-number">36.0.1.</span> <span class="toc-text">XML解析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a><time datetime="2023-05-11T07:11:34.000Z" title="发表于 2023-05-11 15:11:34">2023-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/08/git/" title="git">git</a><time datetime="2023-05-08T08:53:22.000Z" title="发表于 2023-05-08 16:53:22">2023-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/25/Maven%E5%AE%8C%E6%95%B4%E7%89%88/" title="Maven完整版">Maven完整版</a><time datetime="2023-04-25T12:40:29.000Z" title="发表于 2023-04-25 20:40:29">2023-04-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/" title="关于响应状态码">关于响应状态码</a><time datetime="2023-04-19T13:12:15.000Z" title="发表于 2023-04-19 21:12:15">2023-04-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/19/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" title="Web后端开发（初学）">Web后端开发（初学）</a><time datetime="2023-04-19T08:16:12.000Z" title="发表于 2023-04-19 16:16:12">2023-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: #404040"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By yao chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>