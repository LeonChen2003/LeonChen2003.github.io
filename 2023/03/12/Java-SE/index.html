<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java SE | Joker's Warm Cabin</title><meta name="author" content="yao chen"><meta name="copyright" content="yao chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM：java虚拟机，真正运行Java程序的地方  核心类库：Java自己写好的程序，给程序员自己的程序调用的  JRE：JAVA的运行环境，由JVM和核心类库组成  JDK：Java开发工具包，包含上面所有  IDE：集成开发环境，把代码编写，编译，执行等多种功能综合到一起的开发工具   IDEA项目结构 project：项目，工程 module：模块 package：包 class：类">
<meta property="og:type" content="article">
<meta property="og:title" content="Java SE">
<meta property="og:url" content="http://example.com/2023/03/12/Java-SE/index.html">
<meta property="og:site_name" content="Joker&#39;s Warm Cabin">
<meta property="og:description" content="JVM：java虚拟机，真正运行Java程序的地方  核心类库：Java自己写好的程序，给程序员自己的程序调用的  JRE：JAVA的运行环境，由JVM和核心类库组成  JDK：Java开发工具包，包含上面所有  IDE：集成开发环境，把代码编写，编译，执行等多种功能综合到一起的开发工具   IDEA项目结构 project：项目，工程 module：模块 package：包 class：类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/head_picture.png">
<meta property="article:published_time" content="2023-03-12T14:47:30.000Z">
<meta property="article:modified_time" content="2023-03-27T10:17:12.323Z">
<meta property="article:author" content="yao chen">
<meta property="article:tag" content="back-end">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/head_picture.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/12/Java-SE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java SE',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-27 18:17:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_picture.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Joker's Warm Cabin</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java SE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-12T14:47:30.000Z" title="发表于 2023-03-12 22:47:30">2023-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T10:17:12.323Z" title="更新于 2023-03-27 18:17:12">2023-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li><p>JVM：java虚拟机，真正运行Java程序的地方</p>
</li>
<li><p>核心类库：Java自己写好的程序，给程序员自己的程序调用的</p>
</li>
<li><p>JRE：JAVA的运行环境，由JVM和核心类库组成</p>
</li>
<li><p>JDK：Java开发工具包，包含上面所有</p>
</li>
<li><p>IDE：集成开发环境，把代码编写，编译，执行等多种功能综合到一起的开发工具</p>
</li>
</ul>
<h1 id="IDEA项目结构"><a href="#IDEA项目结构" class="headerlink" title="IDEA项目结构"></a>IDEA项目结构</h1><ul>
<li>project：项目，工程</li>
<li>module：模块</li>
<li>package：包</li>
<li>class：类</li>
</ul>
<h1 id="进制表示形式"><a href="#进制表示形式" class="headerlink" title="进制表示形式"></a>进制表示形式</h1><ul>
<li>0表示八进制</li>
<li>0B表示二进制</li>
<li>0x表示十六进制</li>
</ul>
<h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><ul>
<li>也可以成为实体类，其对象可用于在程序中封装数据</li>
</ul>
<p><strong>标准JavaBean需求：</strong></p>
<ul>
<li>成员变量使用private修饰</li>
<li>提供成员变量对应的set和get方法</li>
<li>必须提供一个无参构造器，有参构造器可写可不写</li>
</ul>
<h1 id="String常用API"><a href="#String常用API" class="headerlink" title="String常用API"></a>String常用API</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int length()</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>public char charAt(int index)</td>
<td>获取某个索引位置处的字符</td>
</tr>
<tr>
<td>public char[] toCharArray</td>
<td>将当前字符串转换为字符数组返回</td>
</tr>
<tr>
<td>public String substring(int beginIndex, int endIndex)</td>
<td>根据索引进行截取，包前不包后</td>
</tr>
<tr>
<td>public String substring(int beginIndex)</td>
<td>截取到末尾</td>
</tr>
<tr>
<td>public String replace(CharSequence target, CharSequence replacement)</td>
<td>使用新值将旧值替换，得到新的字符串</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td>根据传入规则切割字符串，得到字符串数组返回</td>
</tr>
</tbody></table>
<h1 id="ArrayList集合常用方法"><a href="#ArrayList集合常用方法" class="headerlink" title="ArrayList集合常用方法"></a>ArrayList集合常用方法</h1><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public E get(int index)</td>
<td>返回指定索引的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中元素的个数</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>public boolean remove(Object o)</td>
<td>删除指定的元素，返回删除是否成功</td>
</tr>
<tr>
<td>public E set(int index, E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
</tbody></table>
<h1 id="static静态关键字"><a href="#static静态关键字" class="headerlink" title="static静态关键字"></a>static静态关键字</h1><ul>
<li><p>static是静态的意思，可以修饰成员变量和成员方法</p>
<p><strong>修饰成员变量</strong></p>
</li>
<li><p>static修饰成员变量表示该成员在内存中只存储一份，可以被共享访问，修改</p>
</li>
<li><p>静态成员变量有static修饰，属于类，加载一次，可以被共享访问（类名.静态成员变量）</p>
</li>
<li><p>实例成员变量无static修饰，属于对象</p>
<p><strong>修饰成员方法</strong></p>
</li>
<li><p>静态成员方法有static修饰，归属于类，建议用类名访问</p>
</li>
<li><p>实例成员方法无static修饰，归属于对象，只能用对象触发访问</p>
</li>
<li><p>表示对象自己行为的，方法中需要访问实例成员的，该方法申明为实例方法</p>
</li>
<li><p>该方法是以执行一个共用功能为目的，申明为静态方法</p>
<p><strong>注意事项</strong></p>
</li>
<li><p>静态方法只能访问静态的成员，不可以直接访问实例成员</p>
</li>
<li><p>实例方法可以访问静态成员，也可以访问实例成员</p>
</li>
<li><p>静态方法不能出现this关键字</p>
<p><strong>工具类</strong></p>
</li>
<li><p>类中都是静态方法，每个方法以完成一个公用的功能为目的，提高代码重用性</p>
</li>
<li><p>由于工具类中均是静态方法，直接用类名访问，工具类无需创建对象，将工具类的构造器私有</p>
<p><strong>代码块</strong></p>
</li>
<li><p>代码块是类的五大成分（成员变量、构造器、方法、代码块、内部类），定义在类的方法之外</p>
</li>
<li><p>在Java类下，使用{}括起来的代码被称为代码块</p>
</li>
<li><p><strong>静态代码块：</strong></p>
<ul>
<li><code>static&#123;&#125;</code></li>
<li>需要通过static关键字修饰，随着类的加载而加载，自动触发，执行一次</li>
<li>在类加载时做一些静态数据初始化的操作，以便后续使用</li>
</ul>
</li>
<li><p><strong>构造代码块</strong></p>
<ul>
<li><code>&#123;&#125;</code></li>
<li>每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行</li>
<li>初始化实例资源</li>
</ul>
</li>
<li><p><strong>单例模式</strong></p>
<ul>
<li><p>饿汉单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">singleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">singleInstance</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleInstance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>super调用父类有参构造器作用：初始化继承自父类的数据（如果父类中没有无参构造器，只有有参构造器则会报错，子类默认调用父类的无参构造器）</li>
<li>子类构造器中可以通过书写super(…)，手动调用父类的有参数构造器</li>
<li><strong><code>this(...)</code>和<code>super(...)</code>注意点：</strong><ul>
<li>子类通过<code>this(...)</code>去调用本类的其他构造器，本类的其他构造器会通过<code>super()</code>去手动调用父类的构造器，最终还是调用父类的构造器</li>
<li><code>this(...)</code>和<code>super(...)</code>只能放在构造器的第一行，所以二者不能放在同一个构造器中</li>
</ul>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li><p>包</p>
<ul>
<li><p>包是用来分门别类管理各种不同类的，类似于文件夹，建包利于程序的管理和维护</p>
</li>
<li><p>导包：相同包下的类可以直接访问，不同包下的类必须导包才可以使用。<strong>导包格式：<code>import 包名.类名</code></strong></p>
</li>
<li><p>如果这个类中使用不同包下相同的类名，此时默认只能导入一个类的包，另一个类要使用全名访问</p>
</li>
</ul>
</li>
<li><p>权限修饰符</p>
<ul>
<li><p>用来控制一个成员能够被访问的范围</p>
</li>
<li><p>可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制</p>
</li>
<li><table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同一个包中的其他类</th>
<th>不同包下的子类</th>
<th>不同包下的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>final</code></p>
<ul>
<li>修饰类：表明该类是最终类，不能被继承</li>
<li>修饰方法：表明该方法是最终方法，不能被重写</li>
<li>修饰变量：表示该变量第一次赋值后，不能被再次赋值</li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li>常量是使用了<code>public static final</code>修饰的成员变量，必须有初始化值，而且在执行的过程中值不能被改变</li>
<li>常量的作用和好处：用作系统的配置信息，方便程序维护，提高可读性</li>
</ul>
</li>
<li><p>枚举</p>
<ul>
<li><p>枚举是Java中的一种特殊数据类型</p>
</li>
<li><p>枚举的作用：为了做信息的标志和信息的分类</p>
</li>
<li><p>枚举格式</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;**</p>
<ul>
<li>修饰符 enum 枚举名称{</li>
<li>第一行是罗列枚举的实例名称</li>
<li>}<br> *&#x2F;<br>public enum Season {<br> SPRING, SUMMER, AUTUMN, WINTER<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 抽象类</span><br><span class="line"></span><br><span class="line">* 类有的成员（成员变量、方法、构造器）抽象类都具备</span><br><span class="line">* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</span><br><span class="line">* 一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义为抽象类</span><br><span class="line">* 不能用abstract修饰变量、代码块、构造器</span><br><span class="line">* **得到了抽象方法，失去了创建对象的能力**</span><br><span class="line"></span><br><span class="line"># 接口</span><br><span class="line"></span><br><span class="line">* 接口不能创建对象</span><br><span class="line">* 一个类实现多个接口，多个接口中有同样的静态方法不冲突</span><br><span class="line">* 一个类继承了父类，同时又实现了接口，父类中和接口有同名方法，默认使用父类的</span><br><span class="line">* 一个类实现了多个接口，多个接口存在同名的默认的方法，不冲突，该类重写该方法即可</span><br><span class="line">* 一个接口继承了多个接口，是允许的，但多个接口中存在规范冲突则不能继承</span><br><span class="line"></span><br><span class="line"># 多态</span><br><span class="line"></span><br><span class="line">* 方法调用：编译看左边，运行看右边</span><br><span class="line">* 变量调用：编译看左边，运行也看左边</span><br><span class="line">* 多态前提：有继承/实现关系，有父类引用指向子类对象，有方法重写</span><br><span class="line">* 在多态形式下，右边对象可以实现解耦合，便于扩展和维护</span><br><span class="line">* 定义方法时，使用父类型作为参数，该方法就可以接受这父类的一切子类对象，体现出多态的扩展性和便利</span><br><span class="line">* **多态下不能使用子类的独有功能**</span><br><span class="line"></span><br><span class="line">* **自动类型转换：**子类对象赋值给父类类型的变量指向</span><br><span class="line">* 强制类型转换</span><br><span class="line">  * 此时必须进行强制类型转换，如果转型后的类型和对象的真实类型不是一种类型，在转换时出现`ClassCastException`</span><br><span class="line"></span><br><span class="line"># 内部类</span><br><span class="line"></span><br><span class="line">* 内部类就是定义在一个类里的类</span><br><span class="line">* 静态内部类</span><br><span class="line">  * static修饰，属于外部类本身</span><br><span class="line">  * 特点与使用与普通类完全一样，只是位置位于其他类里而已</span><br><span class="line">  * 创建格式：`外部类名.内部类名 对象名 = new 外部类名.内部类构造器`</span><br><span class="line">  * **静态内部类不可以直接访问外部类的实例成员，必须通过外部类对象访问**</span><br><span class="line"></span><br><span class="line">* 成员内部类</span><br><span class="line">  * 无static修饰，属于外部类的对象</span><br><span class="line">  * JDK16之前，成员内部类不能定义静态成员，16开始可以定义静态成员</span><br><span class="line">  * 成员内部类创建对象格式：`外部类名.内部类名 对象名 = new 外部类构造器.new 内部类构造器()`</span><br><span class="line">  * **成员内部类可以直接访问外部类的静态成员，也可以直接访问外部类的实例成员**</span><br><span class="line"></span><br><span class="line">* **匿名内部类**</span><br><span class="line">  * 本质上是一个没有名字的局部内部类，定义在方法、代码块等中</span><br><span class="line">  * 作用：方便创建子类对象，最终目的都是为了简化代码</span><br><span class="line">  * 格式：`new 类|抽象类名|接口名()&#123;重写方法&#125;;`</span><br><span class="line">  * 匿名内部类是一个没有名字的内部类</span><br><span class="line">  * 匿名内部类写出来就会产生一个匿名内部类的对象</span><br><span class="line">  * 匿名内部类的对象类型相当于是new的那个的类型的子类类型</span><br><span class="line"></span><br><span class="line"># 常用API</span><br><span class="line"></span><br><span class="line">* **`Object类`**</span><br><span class="line">  * 一个类要么默认继承`Object`类，要么间接继承`Object`类，`Object`是JAVA的祖宗类</span><br><span class="line">  * Object类的方法是一切子类都可以使用的</span><br><span class="line"></span><br><span class="line">| 方法                            | 说明                                   |</span><br><span class="line">| ------------------------------- | -------------------------------------- |</span><br><span class="line">| `public String toString()`      | 默认返回当前对象在堆内存中的地址信息   |</span><br><span class="line">| public Boolean equals(Object o) | 比较当前对象与另一个对象的地址是否相同 |</span><br><span class="line"></span><br><span class="line">默认是打印当前对象的地址</span><br><span class="line"></span><br><span class="line">让子类重写，以便返回子类对象的内容</span><br><span class="line"></span><br><span class="line">* **`Object`中的equals方法**</span><br><span class="line">  * 默认是与另一个对象比较地址是否一样</span><br><span class="line">  * 让子类重写，以便比较2个子类对象的内容是否相同</span><br><span class="line"></span><br><span class="line">* **Objects概述**</span><br><span class="line"></span><br><span class="line">  * Objects类与Object还是继承关系，Objects类是从jdk1.7开始的</span><br><span class="line"></span><br><span class="line">  * | 方法                                              | 说明                                                         |</span><br><span class="line">    | ------------------------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">    | public static boolean equals(Object a , Object b) | 比较两个对象，底层会先进行非空判断，从而可以避免指针异常，在进行equals比较 |</span><br><span class="line">    | public static boolean isNull(Object obj)          | 判断变量是否为null，为null返回true                           |</span><br><span class="line"></span><br><span class="line">* `StringBuilder`</span><br><span class="line">  * `StringBuilder`是一个可变的字符串类，可以将其看成一个对象容器</span><br><span class="line">  * 作用：提高字符串的操作效率，如拼接，修改</span><br><span class="line"></span><br><span class="line">| 名称                             | 说明                                           |</span><br><span class="line">| -------------------------------- | ---------------------------------------------- |</span><br><span class="line">| public StringBuilder()           | 创建一个空白的可变的字符串对象，不包含任何内容 |</span><br><span class="line">| public StringBuilder(String str) | 创建一个指定字符串内容的可变字符串对象         |</span><br><span class="line"></span><br><span class="line">* `Math类`</span><br><span class="line"></span><br><span class="line">  * `Math类`没有公开的构造器</span><br><span class="line"></span><br><span class="line">  * | 方法                                           | 说明                           |</span><br><span class="line">    | ---------------------------------------------- | ------------------------------ |</span><br><span class="line">    | `public static int abs (int a)`                | 取绝对值                       |</span><br><span class="line">    | `public static double ceil(double a)`          | 向上取整                       |</span><br><span class="line">    | `public static double floor(double a)`         | 向下取整                       |</span><br><span class="line">    | `public static int round(float a)`             | 四舍五入                       |</span><br><span class="line">    | `public static int max(int a, int b)`          | 取最大值                       |</span><br><span class="line">    | `public static double pow(double a, double b)` | a的b次方                       |</span><br><span class="line">    | `public static double random()`                | 返回double的随机值，[0.0, 1.0) |</span><br><span class="line"></span><br><span class="line">* `System`类</span><br><span class="line"></span><br><span class="line">  * System的功能是通用的，直接用类名调用，System不能被实例化</span><br><span class="line"></span><br><span class="line">  * | 方法                                                         | 说明                                       |</span><br><span class="line">    | ------------------------------------------------------------ | ------------------------------------------ |</span><br><span class="line">    | `public static void exit(int status)`                        | 终止当前运行的JAVA虚拟机，非零表示异常终止 |</span><br><span class="line">    | `public static long currentTimeMills()`                      | 返回当前系统时间毫秒值形式                 |</span><br><span class="line">    | `public static void arraycopy(数据源数组，起始索引，目的地数组，启示拷贝，拷贝个数)` | 数组拷贝                                   |</span><br><span class="line"></span><br><span class="line">* **BigDecimal**</span><br><span class="line"></span><br><span class="line">  * 解决浮点型运算精度问题</span><br><span class="line"></span><br><span class="line">  * | 方法                                                         | 说明 |</span><br><span class="line">    | ------------------------------------------------------------ | ---- |</span><br><span class="line">    | `public BigDecimal add(BigDecimal b)`                        | 加法 |</span><br><span class="line">    | `public BigDecimal subtract(BigDecimal b)`                   | 减法 |</span><br><span class="line">    | `public BigDecimal multiply(BigDecimal b)`                   | 乘法 |</span><br><span class="line">    | `public BigDecimal divide(BigDecimal b)`                     | 除法 |</span><br><span class="line">    | `public BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式)` | 除法 |</span><br><span class="line"></span><br><span class="line">  * **获取对象方式：`BigDecimal b1 = BigDecimal.valueOf(0.1)`**</span><br><span class="line"></span><br><span class="line">  * 如果选择使用`new BigDecimal()`方法建立对象，括号内应该使用字符串形式而不是浮点型</span><br><span class="line"></span><br><span class="line">* Date类</span><br><span class="line">  </span><br><span class="line">  * `SimpleDateFormat类`</span><br><span class="line">    * 可以把Date对象或者时间毫秒值格式化为我们想要的形式</span><br><span class="line">    * 也可以将字符串时间形式解析为日期对象</span><br><span class="line">  </span><br><span class="line">  * | 方法\|\|构造器                   | 说明                                           |</span><br><span class="line">    | -------------------------------- | ---------------------------------------------- |</span><br><span class="line">    | `public Date()`                  | 创建一个Date对象，代表的是系统当前此刻日期时间 |</span><br><span class="line">    | `public long getTime()`          | 获取当前时间的毫秒值                           |</span><br><span class="line">    | `public Date(long time)`         | 将时间毫秒值转换成Date日期对象                 |</span><br><span class="line">    | `public void setTime(long time)` | 设置日期对象的时间为当前时间毫秒值对应的时间   |</span><br><span class="line">  </span><br><span class="line">  * 获取时间毫秒值</span><br><span class="line">  </span><br><span class="line">    * **创建日期对象，获取时间毫秒值**</span><br><span class="line">    * Date date = new Date();</span><br><span class="line">    * Long time = date.getTime();</span><br><span class="line">    * **毫秒值恢复成日期对象**</span><br><span class="line">    * Date d = new Date(time);</span><br><span class="line">    * d.setTime(time);</span><br><span class="line"></span><br><span class="line">* 包装类</span><br><span class="line">  * 包装类是八种基本数据类型所对应的引用类型</span><br><span class="line">  * 集合和泛型也只支持包装类型，不支持基本数据类型</span><br><span class="line">  * 自动装箱：基本类型的数据和变量可以直接赋给包装类型的变量</span><br><span class="line">  * 自动拆箱：包装类型的变量可以直接赋给基本数据类型的变量</span><br><span class="line">  * **可以将字符串类型的数值转换成真实的数据类型**</span><br><span class="line">  * `Integer.parseInt(&quot;字符串类型的整数&quot;)`</span><br><span class="line">  * **`Integer.valueOf(&quot;&quot;)`**</span><br><span class="line"></span><br><span class="line"># 正则表达式</span><br><span class="line"></span><br><span class="line">正则表达式可以用一些规定的字符来制定规则，校验数据的合法性</span><br><span class="line"></span><br><span class="line">![](./img/exp.png)</span><br><span class="line"></span><br><span class="line">| 方法                                                    | 说明                                                   |</span><br><span class="line">| ------------------------------------------------------- | ------------------------------------------------------ |</span><br><span class="line">| `public String replaceAll(String regex, String newStr)` | 按照正则表达式匹配的内容进行替换                       |</span><br><span class="line">| `public String[] split(String regex)`                   | 按照正则表达式匹配的内容进行分割字符串，返回字符串数组 |</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  //待爬取字符串</span><br><span class="line">        String rs = &quot;dsad@@@ffsfddsd###feff@wddw_@@@fff&quot;;</span><br><span class="line">        //定义爬取规则，字符串形式</span><br><span class="line">        String regex = &quot;\\w&#123;3,5&#125;&quot;;</span><br><span class="line">        //将爬取编译成匹配对象</span><br><span class="line">        Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        //得到内容匹配器对象</span><br><span class="line">        Matcher matcher = pattern.matcher(rs);</span><br><span class="line">        //开始爬取</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            String rs1 = matcher.group();</span><br><span class="line">            System.out.println(rs1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Array类"><a href="#Array类" class="headerlink" title="Array类"></a>Array类</h1><p>数组操作工具类，专门用于操作数组元素</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static String toString(类型[] a)</code></td>
<td>返回字符串</td>
</tr>
<tr>
<td><code>public static void sort(类型[] a)</code></td>
<td>对数组默认进行升序排序</td>
</tr>
<tr>
<td><code>public static&lt;T&gt; void sort(类型[] a, Comparator&lt;? super T&gt; c)</code></td>
<td>使用比较器对象自定义排序</td>
</tr>
<tr>
<td><code>public static int binarySearch(int[] a, int key)</code></td>
<td>二分搜索数据中的数据（数组应提前排好序），存在返回索引，不存在返回不存在的元素应该插入的位置的负数-1</td>
</tr>
</tbody></table>
<ul>
<li><p>默认如果认为左边数据大于右边数据，则返回正整数</p>
</li>
<li><p>左边数据小于右边数据，返回负整数，相等则返回0</p>
</li>
<li><p>使用自定义时被排序的数组必须是引用类型的元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        Integer[] a = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">58</span>, <span class="number">6</span>, <span class="number">98</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认升序排列</span></span><br><span class="line"><span class="comment">//        Arrays.sort(a);</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(a));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用自定义比较器</span></span><br><span class="line">        Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="comment">//return o1 - o2; 升序</span></span><br><span class="line">                <span class="keyword">return</span> o2 - o1;<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>简化匿名内部类的代码写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">   被重写方法具体的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法形式，只能简化接口中只有一个抽象方法的匿名内部类形式</li>
<li>会加上<code>@FunctionalInterface</code>注解，表示接口必须是函数式接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">58</span>, <span class="number">6</span>, <span class="number">98</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义比较器</span></span><br><span class="line">Arrays.sort(a,  (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Lambda表达式省略写法<ul>
<li>参数类型可以省略不写</li>
<li>如果只有一个参数，参数类型可省略，()也可以省略</li>
<li>如果Lambda只有一行代码，可以省略大括号和分号</li>
<li>如果Lambda只有一行代码，可以省略大括号不写，如果是return语句，省略return同时也必须省略’;’</li>
</ul>
</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><p>集合类体系结构</p>
<ul>
<li>Collection单列集合，每个元素（数据）只包含一个值</li>
<li>Map双列集合，每个元素包含两个值（键值对）</li>
<li>集合都是支持泛型的，可在编译阶段约束集合只能操作某种数据类型</li>
<li>集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象</li>
</ul>
</li>
<li><p>Collection集合</p>
<ul>
<li><p>Collection的功能是全部单列集合都可以继承使用的</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean add(E e)</code></td>
<td>添加</td>
</tr>
<tr>
<td><code>public void clean()</code></td>
<td>清空</td>
</tr>
<tr>
<td><code>public boolean remove(E e)</code></td>
<td>删除指定元素</td>
</tr>
<tr>
<td><code>public boolean contains(Object obj)</code></td>
<td>判断当前集合是否包含给定元素</td>
</tr>
<tr>
<td><code>public boolean isEmpty()</code></td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td><code>public int size()</code></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><code>public Object[] toArray()</code></td>
<td>将集合中的元素存储到数组中</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Collection集合遍历</p>
<ul>
<li><strong><code>Iterator()</code>迭代器：</strong></li>
<li>获取：<code>Iterator&lt;E&gt; iterator()</code></li>
<li>方法：<code>boolean hasNext()</code>    <code>E next()</code></li>
<li>迭代器如果取元素越界将出现<code>NoSuchElementException</code>异常</li>
<li><strong><code>foreach/增强for循环</code></strong></li>
<li>既可以遍历数组也可以遍历循环，其内部原理也是一个Iterator迭代器</li>
<li><strong>格式：<code>for(元素数据类型 变量名:数组或者Collection集合)&#123;&#125;</code></strong></li>
<li><strong>Lambda表达式遍历集合</strong></li>
<li><code>lists.forEach(s -&gt; &#123;System.out.println(s)&#125;)</code></li>
</ul>
</li>
</ul>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h4 id="红黑规则"><a href="#红黑规则" class="headerlink" title="红黑规则"></a>红黑规则</h4><ul>
<li>每个节点为黑或者红，根节点必须是黑色</li>
<li>如果一个节点没有子节点或者父节点，该节点响应的指针属性值为nil，nil视为叶节点，叶节点为黑色</li>
<li>某一节点是红色，则子节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><strong>父节点为红色，叔叔节点也为红色</strong></p>
<ul>
<li>将父节点设为黑色，叔叔节点设为黑色</li>
<li>祖父节点也设为红色</li>
<li>如果祖父节点为根节点，则将根节点再次变成黑色</li>
</ul>
<p><strong>父节点为红色，叔叔节点为黑色</strong></p>
<ul>
<li>将父节点设为黑色</li>
<li>祖父节点设为红色</li>
<li>以祖父节点为支点进行旋转</li>
</ul>
<h1 id="List系列集合"><a href="#List系列集合" class="headerlink" title="List系列集合"></a>List系列集合</h1><p><strong>List特有方法：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void add(int index, E element)</code></td>
<td>指定位置插入特定元素</td>
</tr>
<tr>
<td><code>E remove(int index)</code></td>
<td>删除指定位置元素</td>
</tr>
<tr>
<td><code>E set(int index, E element)</code></td>
<td>修改指定位置元素</td>
</tr>
<tr>
<td><code>E get(int index)</code></td>
<td>返回指定位置元素</td>
</tr>
</tbody></table>
<ul>
<li>ArrayList基于数组实现，第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型：可以在编译阶段约束操作的数据类型，并进行检查</p>
<p>格式：&lt;数据类型&gt;</p>
<p>集合体系的全部接口和实现类都是支持泛型使用的</p>
<ul>
<li><p><strong>泛型类</strong></p>
<ul>
<li>定义类时同时定义了泛型的类就是泛型类</li>
<li>格式：修饰符 class 类名&lt;泛型变量&gt;{}</li>
</ul>
</li>
<li><p><strong>泛型方法</strong></p>
<ul>
<li>定义方法的同时定义了泛型的方法就是泛型方法</li>
<li>格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</li>
<li>方法中可以使用泛型接收一切实际类型的参数，方法更具通用性</li>
</ul>
</li>
<li><p><strong>泛型接口</strong></p>
<ul>
<li>使用泛型定义的接口</li>
<li>修饰符 interface 接口名称&lt;泛型变量&gt;{}</li>
</ul>
</li>
<li><p><strong>通配符：？</strong></p>
<ul>
<li>？可以在定义泛型的时候使用</li>
<li><code>? extends Car</code>：？必须是Car的子类或Car，泛型上限</li>
<li><code>？super Car</code>：？必须是Car或者其父类，泛型下限</li>
</ul>
</li>
</ul>
<h1 id="Set系列集合"><a href="#Set系列集合" class="headerlink" title="Set系列集合"></a>Set系列集合</h1><p><strong>无序、不重复、无索引</strong></p>
<ul>
<li>HashSet：无序，不重复，无索引</li>
<li>LinkedHashSet：有序，不重复，无索引</li>
<li>TreeSet：排序、不重复、无索引</li>
<li><strong>HashSet集合底层采用哈希表存储数据</strong></li>
</ul>
<p><strong>哈希值：JDK根据对象的地址，按照某种规则算出来的int类型的数值</strong></p>
<p><code>public int hashCode()</code>：返回对象的哈希值</p>
<ul>
<li>同一个对象返回的哈希值相同</li>
<li>默认情况下，不同对象的哈希值不同</li>
<li><strong>底层原理：JDK8之前，采用数组＋链表，8之后，当链表元素过多时将转换为红黑树，底层采用数组+链表+红黑树的形式</strong></li>
</ul>
<p><strong>哈希表流程：</strong></p>
<ul>
<li>创建一个默认长度为16，加载因为0.75的数组</li>
<li>根据哈希值跟数组长度计算存入位置</li>
<li>判断当前位置是否为null，是则直接存入，不是则比较属性值，一样则不存，不一样则存入数组</li>
<li>数组存满16*0.75&#x3D;12时，自动扩容，每次扩容原先两倍</li>
</ul>
<p><strong>LinkedHashSet集合底层基于哈希表，使用双链表记录添加顺序</strong></p>
<p><strong>TreeSet集合底层基于红黑树的数据结构实现排序</strong></p>
<ul>
<li>TreeSet集合存储对象的时候有两种方式可以设计自定义比较规则<ul>
<li>让自定义类实现<code>Comparable</code>接口重写里面的<code>compareTo</code>方法来制定比较规则</li>
<li><code>TreeSet</code>集合有参数构造器，可以设置<code>Comparator</code>接口对应的比较器对象，来定制比较规则</li>
<li><code>TreeSet</code>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Apple</span> <span class="variable">apple1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;111&quot;</span>, <span class="number">12.8</span>, <span class="number">120</span>);</span><br><span class="line">    <span class="type">Apple</span> <span class="variable">apple2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;222&quot;</span>, <span class="number">15.6</span>, <span class="number">560</span>);</span><br><span class="line">    <span class="type">Apple</span> <span class="variable">apple3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;333&quot;</span>, <span class="number">3.9</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;? <span class="built_in">super</span> Apple&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getWeight() - o2.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    treeSet.add(apple1);</span><br><span class="line">    treeSet.add(apple2);</span><br><span class="line">    treeSet.add(apple3);</span><br><span class="line"></span><br><span class="line">    System.out.println(treeSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li>可变参数用在形参中接收多个数据</li>
<li>可变参数格式：数据类型…参数名称</li>
<li>传输参数灵活，可以不传参数，可以传1个或者多个，也可以传输一组数据</li>
<li>可变参数在方法内部本质就是一个数组</li>
<li><strong>一个形参列表中可变参数只能有一个，可变参数必须放在形参列表的最后</strong></li>
</ul>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><ul>
<li>Map集合是一种双列集合，每个元素包含两个数据</li>
<li>Map集合元素格式：key&#x3D;value(键值对元素)</li>
<li>Map集合也称为键值对集合</li>
<li><strong>Map集合的键无序，不重复；Map集合的值不做要求，可以重复</strong></li>
<li><code>HashMap</code>：元素按照键是无序，不重复，无索引，值不做要求，与Map体系一致</li>
<li><code>LinkedHashMap</code>：元素按照键是有序，不重复，无索引，值不做要求</li>
<li><code>TreeMap</code>：元素按照键是排序，不重复，无索引的，值不做要求</li>
</ul>
<p><strong>常用API(Map API)</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V put(K key, V value)</code></td>
<td>添加元素</td>
</tr>
<tr>
<td><code>V remove(Object key)</code></td>
<td>删除元素</td>
</tr>
<tr>
<td><code>void clear()</code></td>
<td>移除所有元素</td>
</tr>
<tr>
<td><code>boolean containsKey(Object key)</code></td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td><code>boolean containsValue(Object value)</code></td>
<td>判断是否包含指定的值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><code>int size()</code></td>
<td>集合长度</td>
</tr>
</tbody></table>
<p><strong>Map集合遍历方式</strong></p>
<p><strong>键找值</strong></p>
<ol>
<li>获取Map集合的全部键的Set集合</li>
<li>遍历键的Set集合，通过键提取对应值</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set&lt;K&gt; KeySet()</code></td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td><code>V get(Object key)</code></td>
<td>根据键获取值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;2&quot;</span>, <span class="number">236</span>);</span><br><span class="line">    map.put(<span class="string">&quot;3&quot;</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = map.keySet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s: set)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(s);</span><br><span class="line">        System.out.println(s +<span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>键值对</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td><code>K getKey()</code></td>
<td>获得键</td>
</tr>
<tr>
<td><code>V getValue()</code></td>
<td>获得值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="number">236</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">    System.out.println(key + <span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v) -&gt; &#123;</span><br><span class="line">    System.out.println(k + <span class="string">&quot;===&gt;&quot;</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>创建不可变集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = List.of(<span class="number">12.5</span>, <span class="number">15.9</span>, <span class="number">12.4</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p><strong>Stream流的三类方法：</strong></p>
<ul>
<li>获取Stream流：创建一条流水线，将数据放到流水线上进行操作</li>
<li>中间方法：一次操作完毕后，还可以继续进行其他操作</li>
<li>终结方法：一个Stream流只能有一个终结方法，是流水线上最后一个操作</li>
</ul>
<p>获取方式：</p>
<ul>
<li>集合可以直接获取stream流</li>
<li>Map可以可通过获取键流或直流或者调用Entry获取键值对流</li>
<li>数组调用<code>Arrays.stream()</code>方法获取</li>
</ul>
<p><strong>常用API</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td>用于对流中的数据进行过滤</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; limit(long maxSize)</code></td>
<td>获取前几个元素</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; skip(long n)</code></td>
<td>跳过前几个元素</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; distinct()</code></td>
<td>去除流中重复的元素</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)</code></td>
<td>合并a、b流为一个流</td>
</tr>
<tr>
<td><code>void forEach(Consumer action)</code></td>
<td>对此流的每个元素进行遍历操作</td>
</tr>
<tr>
<td><code>long count()</code></td>
<td>返回此流中的元素数</td>
</tr>
</tbody></table>
<ul>
<li>map加工方法：第一个参数原材料 -&gt; 第二个参数为加工后的结果</li>
<li><code>list.stream().map(s -&gt; &quot;附加内容&quot; + s)</code></li>
<li>在Stream流中无法直接修改集合、数组中的元素</li>
</ul>
<p><strong>Stream流收集操作</strong></p>
<p>将stream流操作后的结果数据转回到集合或者数组当中</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>R collect(Collector collector)</code></td>
<td>开始收集stream流，指定收集器</td>
</tr>
<tr>
<td><code>public static &lt;T&gt; Collector toList()</code></td>
<td>把元素收集到List集合当中</td>
</tr>
<tr>
<td><code>public static &lt;T&gt; Collector toSet()</code></td>
<td>将元素收集到Set集合当中</td>
</tr>
<tr>
<td><code>public static Collector toMap(Function keyMapper, Function valueMapper)</code></td>
<td>把元素收集到Map集合当中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).distinct();</span><br><span class="line">    List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String k:</span><br><span class="line">         list1) &#123;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常程序指在编译或者执行时出现的问题，如数组越界、空指针异常、日期格式化异常，语法错误不算在异常体系内</p>
<ul>
<li><strong>Error：</strong>系统级别问题</li>
<li><strong>Exception：</strong>java.lang包下，称为异常类，表示程序本身可以处理的问题<ul>
<li><code>RuntimeException</code>及其子类：运行时异常，编译阶段不会报错（空指针异常，数组越界）</li>
<li>除<code>RuntimeException</code>之外的所有异常：编译时异常，编译期必须处理，否则程序不能通过编译。（日期格式化异常）</li>
</ul>
</li>
</ul>
<p><strong>运行异常：直接继承自RuntimeException或者子类</strong></p>
<ul>
<li>数组越界异常：<code>ArrayIndexOutOfBoundsException</code></li>
<li>空指针异常：<code>NullPointerException</code></li>
<li>数学操作异常：<code>ArithmeticException</code></li>
<li>类型转换异常：<code>ClassCastException</code></li>
<li>数字转换异常：<code>NumberFormatException</code></li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><p><code>throws</code>：用在方法上，将方法内部的异常抛出去给本方法的调用者处理</p>
</li>
<li><p><code>try...catch...</code>：监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理，发生异常的方法自己独立完成异常处理，程序可以继续往下执行</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Exception可以捕获处理一切异常类型</p>
<ul>
<li>方式三：方法直接将异常通过throws抛出去给调用者，调用者收到异常后处理异常</li>
</ul>
<p>在开发中底层的异常抛出去给最外层，最外层集中捕获处理使用较多</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>可以将系统执行的信息选择性的记录到指定位置，可以随时以开关的形式控制是否记录日志</p>
<h2 id="Logback日志框架"><a href="#Logback日志框架" class="headerlink" title="Logback日志框架"></a>Logback日志框架</h2><ul>
<li>slf4j-api：日志规范</li>
<li>logback-core：基础模块</li>
<li>logback-classic：是log4j的一个改良版本，同时完整实现了slf4j API</li>
</ul>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean isDirectory()</code></td>
<td>测试此抽象路径名表示的FIle是否为文件夹</td>
</tr>
<tr>
<td><code>public boolean isFile()</code></td>
<td>测试路径名表示的File是否为文件</td>
</tr>
<tr>
<td><code>public boolean exists()</code></td>
<td>测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td><code>public String getAbsolutePath()</code></td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td><code>public String getPath()</code></td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td><code>public String getName()</code></td>
<td>返回由此抽象路径名表示的文件或文件夹名称</td>
</tr>
<tr>
<td><code>public long lastModified()</code></td>
<td>返回文件最后修改的毫秒值</td>
</tr>
</tbody></table>
<p><strong>创建与删除</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean createNewFile()</code></td>
<td>创建一个新的空的文件</td>
</tr>
<tr>
<td><code>public boolean mkdir()</code></td>
<td>只能创建一级文件夹</td>
</tr>
<tr>
<td><code>public boolean mkdirs()</code></td>
<td>可以创建多级文件夹</td>
</tr>
<tr>
<td><code>public boolean delete()</code></td>
<td>删除由此抽象路径名表示的文件或者空文件夹</td>
</tr>
</tbody></table>
<p>delete方法是不走回收站的，只能删空文件夹，不能删非空文件夹</p>
<p><strong>遍历文件夹</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public String[] list()</code></td>
<td>获取当前目录下所有一级文件名称到i一个字符串数组中去返回</td>
</tr>
<tr>
<td><code>public File[] listFiles()</code></td>
<td>获取当前目录下所有一级文件对象到一个文件对象数组中去返回（常用）</td>
</tr>
</tbody></table>
<p><strong>listFiles：</strong></p>
<ul>
<li>当调用者不存在或者是一个文件时，返回null</li>
<li>当调用者是一个空文件时，返回一个长度为0的数组</li>
<li>当调用者是一个有内容的文件夹时，将里面的所有文件和文件夹的路径放在File数组中返回</li>
</ul>
<p><strong>递归文件搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;aDrive.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            searchFile(dir, fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.isFile() &amp;&amp; dir.getName().equals(fileName)) &#123;</span><br><span class="line">            System.out.println(dir.getAbsoluteFile());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir.isDirectory() &amp;&amp; dir != <span class="literal">null</span>) &#123;</span><br><span class="line">            File[] files = dir.listFiles();</span><br><span class="line">                <span class="keyword">for</span> (File file : files</span><br><span class="line">                ) &#123;</span><br><span class="line">                    searchFile(file, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte[] getBytes()</code></td>
<td>使用默认字符集将其编码为一系列字节并存储到数组中</td>
</tr>
<tr>
<td><code>byte[] getBytes(String charsetName)</code></td>
<td>使用指定字符集将其编码为一系列字节并存储到数组中</td>
</tr>
<tr>
<td><code>String(byte[] bytes)</code></td>
<td>使用默认字符集构造新的String</td>
</tr>
<tr>
<td><code>String(byte[] bytes, String charsetName)</code></td>
<td>通过指定字符集解码指定的字符数组构造新的String</td>
</tr>
</tbody></table>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/IOStream.png"></p>
<p>文件输入流：<code>FileInputStream</code></p>
<ul>
<li><p>以内存为基准，将磁盘文件中的数据按字节形式读取到内存</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public int read()</code></td>
<td>每次读取一个字节返回，读完则返回-1</td>
</tr>
<tr>
<td><code>public int read(byte[] buffer)</code></td>
<td>读取一个字节数组返回，字节没有可读返回-1</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public byte[] readAllBytes() throws IOException</code></td>
<td>直接将当前字节输入流对应的文件对象的字节数据撞到一个字节数组返回</td>
</tr>
</tbody></table>
</li>
</ul>
<p>文件输出流：<code>FileOutStream</code></p>
<ul>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public void write(int a)</code></td>
<td>写一个字节出去</td>
</tr>
<tr>
<td><code>public void write(byte[] buffer)</code></td>
<td>写一个字节数组出去</td>
</tr>
<tr>
<td><code>public void write(byte[] buffer, int pos, int len)</code></td>
<td>写一个字节数组的一部分</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flush()</code></td>
<td>刷新流</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭流，释放资源</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>文件拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./pre.txt&quot;</span>);</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./copy.txt&quot;</span>);</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./pre.txt&quot;</span>);</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./copy.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>JDK7以及9try中的()只能放置资源对象，<strong>资源都是实现了Closeable&#x2F;AutoCloseable接口的类对象</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">yao chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/12/Java-SE/">http://example.com/2023/03/12/Java-SE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Joker's Warm Cabin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/back-end/">back-end</a></div><div class="post_share"><div class="social-share" data-image="/img/head_picture.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/05/%E5%85%B3%E4%BA%8EExpress/" title="关于Express"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于Express</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head_picture.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yao chen</div><div class="author-info__description">故事要美必须藏着真话</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JOKER1515"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Irregular renewal.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IDEA%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">IDEA项目结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">进制表示形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaBean"><span class="toc-number">3.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8API"><span class="toc-number">4.</span> <span class="toc-text">String常用API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">ArrayList集合常用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">static静态关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Array%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">Array类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">12.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E8%A7%84%E5%88%99"><span class="toc-number">12.0.0.1.</span> <span class="toc-text">红黑规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">12.0.0.2.</span> <span class="toc-text">插入</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">13.</span> <span class="toc-text">List系列集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">14.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">15.</span> <span class="toc-text">Set系列集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">17.</span> <span class="toc-text">Map集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">18.</span> <span class="toc-text">Stream流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">19.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">19.0.0.1.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">20.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Logback%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-number">20.1.</span> <span class="toc-text">Logback日志框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">21.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="toc-number">22.</span> <span class="toc-text">编码与解码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">23.</span> <span class="toc-text">IO流</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/12/Java-SE/" title="Java SE">Java SE</a><time datetime="2023-03-12T14:47:30.000Z" title="发表于 2023-03-12 22:47:30">2023-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/05/%E5%85%B3%E4%BA%8EExpress/" title="关于Express">关于Express</a><time datetime="2023-03-05T06:46:55.000Z" title="发表于 2023-03-05 14:46:55">2023-03-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/30/%E5%88%9D%E8%AF%86Node-js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/" title="初识Node.js与内置模块">初识Node.js与内置模块</a><time datetime="2023-01-30T13:20:18.000Z" title="发表于 2023-01-30 21:20:18">2023-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/28/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/" title="PC端网页特效">PC端网页特效</a><time datetime="2023-01-28T11:09:25.000Z" title="发表于 2023-01-28 19:09:25">2023-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/27/%E5%85%B3%E4%BA%8EJavaScript%E6%89%A7%E8%A1%8C%E6%A0%88/" title="关于JavaScript执行栈">关于JavaScript执行栈</a><time datetime="2023-01-27T11:45:15.000Z" title="发表于 2023-01-27 19:45:15">2023-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: #404040"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By yao chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>